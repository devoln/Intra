#include "Core/Core.h"
#include "Graphics/OpenGL/GraphicsGL.h"

#include "Windowing/GraphicsWindow.h"
#include "IO/Stream.h"
#include "Imaging/Image.h"

#include "Graphics/GLExtensions.h"	//Инициализация расширений OpenGL

#include "Imaging/Bindings/GLenumFormats.h"


#ifdef _MSC_VER
#pragma comment(lib, "opengl32.lib")
#endif

#undef NO_ERROR

using namespace math;
using namespace Memory;
using namespace IO;

#define GL OpenGL
#undef MemoryBarrier


enum class MipmapState: byte {AutoGenerateDirty, AutoGenerate, Manual};

struct AGraphics::MemoryBlock
{
	MemoryFlags flags;
	uint size;
};

struct AGraphics::Texture
{
	uint id;
	ImageInfo info;
	MipmapState mipstate;
};

struct AGraphics::ShaderObject
{
	uint id;
};

struct AGraphics::BufferView
{
	uint id;
	uint size;
	bool inited;
	MemoryBlock* block;
	uint startInBlock;
	LockAccess lock_access;
	bool unsychronized_lock;
	uint locked_start, locked_end;
};

namespace  //Вспомогательные функции, структуры и таблицы
{
	//Конвертирование перечислений в константы OpenGL

	GLenum uniformTypeToGLType(UniformType t)
	{
		if(!t.IsValid()) return 0;

		static const ushort scalVecTable[]={
			0,

			GL::FLOAT, GL::FLOAT_VEC2, GL::FLOAT_VEC3, GL::FLOAT_VEC4,
			GL::DOUBLE, GL::DOUBLE_VEC2, GL::DOUBLE_VEC3, GL::DOUBLE_VEC4,
			0,0,0,0,
			0,

			GL::INT, GL::INT_VEC2, GL::INT_VEC3, GL::INT_VEC4,
			GL::UNSIGNED_INT, GL::UNSIGNED_INT_VEC2, GL::UNSIGNED_INT_VEC3, GL::UNSIGNED_INT_VEC4,
		};
		static_assert(numof(scalVecTable)==ValueType::UVec4+1, "Table is outdated!");

		static const ushort matricesTable[]=
		{
			GL::FLOAT_MAT2, GL::FLOAT_MAT2x3, GL::FLOAT_MAT2x4, GL::FLOAT_MAT3x2,
			GL::FLOAT_MAT3, GL::FLOAT_MAT3x4, GL::FLOAT_MAT4x2, GL::FLOAT_MAT4x3, GL::FLOAT_MAT4,

			GL::DOUBLE_MAT2, GL::DOUBLE_MAT2x3, GL::DOUBLE_MAT2x4, GL::DOUBLE_MAT3x2,
			GL::DOUBLE_MAT3, GL::DOUBLE_MAT3x4, GL::DOUBLE_MAT4x2, GL::DOUBLE_MAT4x3, GL::DOUBLE_MAT4
		};
		static_assert(numof(matricesTable)==ValueType::EndOfMatrices-ValueType::FirstOfMatrices, "Table is outdated!");

		static const ushort otherTable[]
		{
			GL::SAMPLER_1D, GL::SAMPLER_1D_ARRAY, GL::SAMPLER_2D, GL::SAMPLER_2D_ARRAY,
			GL::SAMPLER_CUBE, GL::SAMPLER_CUBE_MAP_ARRAY, GL::SAMPLER_3D, GL::SAMPLER_2D_MULTISAMPLE, GL::SAMPLER_BUFFER,
			GL::SAMPLER_2D_SHADOW, GL::SAMPLER_2D_ARRAY_SHADOW, GL::SAMPLER_CUBE_SHADOW, GL::SAMPLER_CUBE_MAP_ARRAY_SHADOW,

			GL::INT_SAMPLER_1D, GL::INT_SAMPLER_1D_ARRAY, GL::INT_SAMPLER_2D, GL::INT_SAMPLER_2D_ARRAY,
			GL::INT_SAMPLER_CUBE, GL::INT_SAMPLER_CUBE_MAP_ARRAY, GL::INT_SAMPLER_3D, GL::INT_SAMPLER_2D_MULTISAMPLE, GL::INT_SAMPLER_BUFFER,

			GL::UNSIGNED_INT_SAMPLER_1D, GL::UNSIGNED_INT_SAMPLER_1D_ARRAY, GL::UNSIGNED_INT_SAMPLER_2D, GL::UNSIGNED_INT_SAMPLER_2D_ARRAY,
			GL::UNSIGNED_INT_SAMPLER_CUBE, GL::UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY, GL::UNSIGNED_INT_SAMPLER_3D, GL::UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE, GL::UNSIGNED_INT_SAMPLER_BUFFER,


			GL::IMAGE_1D, GL::IMAGE_2D, GL::IMAGE_3D, GL::IMAGE_CUBE, GL::IMAGE_BUFFER, GL::IMAGE_1D_ARRAY,
			GL::IMAGE_2D_ARRAY, GL::IMAGE_CUBE_MAP_ARRAY, GL::IMAGE_2D_MULTISAMPLE, GL::IMAGE_2D_MULTISAMPLE_ARRAY,

			GL::INT_IMAGE_1D, GL::INT_IMAGE_2D, GL::INT_IMAGE_3D, GL::INT_IMAGE_CUBE, GL::INT_IMAGE_BUFFER, GL::INT_IMAGE_1D_ARRAY,
			GL::INT_IMAGE_2D_ARRAY, GL::INT_IMAGE_CUBE_MAP_ARRAY, GL::INT_IMAGE_2D_MULTISAMPLE, GL::INT_IMAGE_2D_MULTISAMPLE_ARRAY,

			GL::UNSIGNED_INT_IMAGE_1D, GL::UNSIGNED_INT_IMAGE_2D, GL::UNSIGNED_INT_IMAGE_3D, GL::UNSIGNED_INT_IMAGE_CUBE, GL::UNSIGNED_INT_IMAGE_BUFFER, GL::UNSIGNED_INT_IMAGE_1D_ARRAY,
			GL::UNSIGNED_INT_IMAGE_2D_ARRAY, GL::UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY, GL::UNSIGNED_INT_IMAGE_2D_MULTISAMPLE, GL::UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY,


			0, 0
		};
		static_assert(numof(otherTable)==UniformType::End-ValueType::End, "Table is outdated!");

		if(t.IsSampler()) return otherTable[t.value-UniformType::FirstOfSamplers];
		else if(t.IsMatrix()) return matricesTable[t.value-ValueType::FirstOfMatrices];
		else if(t.value<=ValueType::UVec4) return scalVecTable[t.value];
		return 0;
	}

	GLenum attribTypeToGLType(ValueType t)
	{
		if(t.value>=ValueType::EndOfVectors) return 0;

		static const ushort scalVecTable[]={
			0,

			GL::FLOAT, GL::FLOAT, GL::FLOAT, GL::FLOAT,
			GL::DOUBLE, GL::DOUBLE, GL::DOUBLE, GL::DOUBLE,
			GL::HALF_FLOAT, GL::HALF_FLOAT, GL::HALF_FLOAT, GL::HALF_FLOAT,

			GL::UNSIGNED_INT_10F_11F_11F_REV,

			GL::INT, GL::INT, GL::INT, GL::INT,
			GL::UNSIGNED_INT, GL::UNSIGNED_INT, GL::UNSIGNED_INT, GL::UNSIGNED_INT,
			GL::SHORT, GL::SHORT, GL::SHORT, GL::SHORT,
			GL::UNSIGNED_SHORT, GL::UNSIGNED_SHORT, GL::UNSIGNED_SHORT, GL::UNSIGNED_SHORT,
			GL::BYTE, GL::BYTE, GL::BYTE, GL::BYTE,
			GL::UNSIGNED_BYTE, GL::UNSIGNED_BYTE, GL::UNSIGNED_BYTE, GL::UNSIGNED_BYTE,
			0, 0, 0, 0,

			0, GL::UNSIGNED_INT_2_10_10_10_REV, 0,

			GL::UNSIGNED_BYTE, GL::UNSIGNED_BYTE, GL::UNSIGNED_BYTE, GL::UNSIGNED_BYTE,
			GL::UNSIGNED_SHORT, GL::UNSIGNED_SHORT, GL::UNSIGNED_SHORT, GL::UNSIGNED_SHORT,
			GL::UNSIGNED_INT, GL::UNSIGNED_INT, GL::UNSIGNED_INT, GL::UNSIGNED_INT,
			GL::BYTE, GL::BYTE, GL::BYTE, GL::BYTE,
			GL::SHORT, GL::SHORT, GL::SHORT, GL::SHORT,
			GL::INT, GL::INT, GL::INT, GL::INT,

			0,0,0,0, GL::UNSIGNED_INT_2_10_10_10_REV, GL::INT_2_10_10_10_REV, 0, 0, 0, 0
		};
		static_assert(numof(scalVecTable)==ValueType::EndOfVectors, "Table is outdated!");

		return scalVecTable[t.value];
	}

	const ushort blendFactorConvertTable[10]={GL::ZERO, GL::ONE, GL::SRC_COLOR, GL::ONE_MINUS_SRC_COLOR,
		GL::SRC_ALPHA, GL::ONE_MINUS_SRC_ALPHA, GL::DST_COLOR, GL::ONE_MINUS_DST_COLOR, GL::DST_ALPHA, GL::ONE_MINUS_DST_ALPHA};

	const ushort polyModeConvertTable[3]={GL::FILL, GL::POINT, GL::LINE};

	const ushort texWrapConvertTable[3]={GL::CLAMP_TO_EDGE, GL::REPEAT, GL::MIRRORED_REPEAT};
	const ushort texFilterConvertTable[3]={GL::NEAREST, GL::LINEAR, GL::NEAREST};

	const ushort texCompareModeConvertTable[2]={GL::NONE, GL::COMPARE_R_TO_TEXTURE};
	static_assert(numof(texCompareModeConvertTable)==(uint)DepthTexCompareMode::End, "Table size doesn't match enum CompareFunc!");

	const ushort compareFuncConvertTable[]={GL::LEQUAL, GL::GEQUAL, GL::LESS, GL::GREATER, GL::EQUAL, GL::NOTEQUAL, GL::ALWAYS, GL::NEVER};
	static_assert(numof(compareFuncConvertTable)==(uint)CompareFunc::End, "Table size doesn't match enum CompareFunc!");

	/*const ushort uniformTypeConvertTable[]={0,
		GL::FLOAT, GL::FLOAT_VEC2, GL::FLOAT_VEC3, GL::FLOAT_VEC4,
		GL::DOUBLE, GL::DOUBLE_VEC2, GL::DOUBLE_VEC3, GL::DOUBLE_VEC4,
		0,0,0,0,
		0,
		GL::INT, GL::INT_VEC2, GL::INT_VEC3, GL::INT_VEC4,
		GL::UNSIGNED_INT, GL::UNSIGNED_INT_VEC2, GL::UNSIGNED_INT_VEC3, GL::UNSIGNED_INT_VEC4,

		//Типы, которые не могут иметь uniform-переменные
		0,0,0,0,
		0,0,0,0,
		0,0,0,0,
		0,0,0,0,
		0,0,0,

		0,0,0,0,
		0,0,0,0,
		0,0,0,0,
		0,0,0,0,
		0,0,0,0,
		0,0,0,0,

		0,0,0,0,0,

		GL::FLOAT_MAT2, GL::FLOAT_MAT2x3, GL::FLOAT_MAT2x4,
		GL::FLOAT_MAT3x2, GL::FLOAT_MAT3, GL::FLOAT_MAT3x4,
		GL::FLOAT_MAT4x2, GL::FLOAT_MAT4x3, GL::FLOAT_MAT4,

		GL::DOUBLE_MAT2, GL::DOUBLE_MAT2x3, GL::DOUBLE_MAT2x4,
		GL::DOUBLE_MAT3x2, GL::DOUBLE_MAT3, GL::DOUBLE_MAT3x4,
		GL::DOUBLE_MAT4x2, GL::DOUBLE_MAT4x3, GL::DOUBLE_MAT4,
	
		GL::SAMPLER_1D, GL::SAMPLER_1D_ARRAY, GL::SAMPLER_2D, GL::SAMPLER_2D_ARRAY, GL::SAMPLER_CUBE, GL::SAMPLER_3D,
		0,0
	};
	static_assert(sizeof(uniformTypeConvertTable)/sizeof(uniformTypeConvertTable[0])==UniformType::Max, "Table is outdated!");*/

	const ushort primitiveTypeConvertTable[6]={GL::POINTS, GL::LINES, GL::LINE_STRIP, GL::TRIANGLES, GL::TRIANGLE_STRIP, GL::TRIANGLE_FAN};

	ushort convertMinFilter(TexFilter Min, TexFilter mip)
	{
		if((ushort)Min>=(ushort)TexFilter::AnisotropicX2) Min=TexFilter::Linear, mip=TexFilter::Linear;
		if(Min==TexFilter::Linear)
		{
			static const ushort match[]={GL::LINEAR_MIPMAP_NEAREST, GL::LINEAR_MIPMAP_LINEAR, GL::LINEAR};
			return match[(ushort)mip];
		}
		static const ushort match[]={GL::NEAREST_MIPMAP_NEAREST, GL::NEAREST_MIPMAP_LINEAR, GL::NEAREST};
		return match[(ushort)mip];
	}
	enum AttribType {AttribType_Position, AttribType_Normal, AttribType_Binormal, AttribType_Tangent, AttribType_TexCoord};

	GLenum convertToGLTarget(AGraphics::Texture* tex, ushort face=0)
	{
		if(tex==null) return 0;
		if(tex->info.Type==ImageType_Cube) return CubeFaceToGLTarget(CubeFace(face));
		return ImageTypeToGLTarget(tex->info.Type);
	}

	static void setFramebufferTexture(const AGraphics::FramebufferAttachment& at, short i, const OpenGL& gl, GLenum fboTarget)
	{
		GLenum attachment = GLenum( GL::COLOR_ATTACHMENT0+i );
		if(i==-1) attachment = GL::DEPTH_ATTACHMENT;
		if(i==-2) attachment = GL::STENCIL_ATTACHMENT;

		if(at.tex->info.Type==ImageType_2D || at.tex->info.Type==ImageType_Cube)
		{
			uint id=0, mip=0;
			GLenum texTarget=GL::TEXTURE_2D;
			id=at.tex->id, mip=at.miplevel;
			if(at.tex->info.Type==ImageType_Cube)
				texTarget=CubeFaceToGLTarget(CubeFace(at.slice));
			gl.FramebufferTexture2D(fboTarget, attachment, texTarget, id, (int)mip);
			return;
		}

		if(at.tex->info.Type==ImageType_3D || at.tex->info.Type==ImageType_2DArray)
		{
			if(gl.FramebufferTextureLayer!=null) //Эта функция появилась только в OpenGL 3.2 и заменяет вариант 3D
				gl.FramebufferTextureLayer(GL::FRAMEBUFFER, attachment, at.tex->id, at.miplevel, at.slice);
			else
				gl.FramebufferTexture3D(GL::FRAMEBUFFER, attachment, ImageTypeToGLTarget(at.tex->info.Type), at.tex->id, at.miplevel, at.slice);
			return;
		}
	}

#ifndef _NO_LOGGING
	static string texture_ToString(AGraphics::Texture* tex, bool swizzle)
	{
		if(tex==null) return "null";
		return string::Format("id=<^>, format=0x<^>, internalFormat=0x<^>, size={<^>, <^>, <^>}, mipmaps=<^>")
			(tex->id)
			(ImageFormatToGLExternal(tex->info.Format, false, swizzle), 4, '0', 16)
			(ImageFormatToGLInternal(tex->info.Format, swizzle), 4, '0', 16)
			(tex->info.Size.x)(tex->info.Size.y)(tex->info.Size.z)(tex->info.MipmapCount);
	}
#endif
}

static Map<ushort, UniformType> uniformTypeFromGL;

#include "IO/Stream.h"
#include "Platform/WindowSystemApi.h"

#ifndef _NO_LOGGING
void GLCALL GL_debug_output_callback(GLenum source, GLenum type, uint /*id*/,
	GLenum /*severity*/, int /*length*/, const char* message, const void* userParam)
{
	if(source==GL::DEBUG_SOURCE_SHADER_COMPILER) return; //Ошибки компиляции и компоновки шейдеров записываются в лог вручную
	const auto This = (GraphicsGL*)userParam;

	Logger* logger=null;

	StringView msg = StringView(message);
	switch(type)
	{
	case GL::DEBUG_TYPE_ERROR:
	case GL::DEBUG_TYPE_UNDEFINED_BEHAVIOR:
		logger = &This->ErrorLog;
		logger->PushStyle("error");
		break;

	case GL::DEBUG_TYPE_DEPRECATED_BEHAVIOR:
	case GL::DEBUG_TYPE_PORTABILITY:
		logger = &This->WarnLog;
		logger->PushStyle("warn");
		break;

	case GL::DEBUG_TYPE_PERFORMANCE:
		logger = &This->PerfWarnLog;
		logger->PushStyle("perf");
		break;
	}

	if(logger==null) return;

	*logger << msg << endl;
	logger->PopStyle();
}
#endif

GraphicsGL::GraphicsGL(GraphicsWindow* wnd, uint msaaSamples, bool enableVSync, bool coreProfile, bool enableDebug, bool linearSpace):
	AGraphics(wnd), gl()
{
	gapi = GraphicsAPI::OpenGL;
	assert(wnd!=null);
	context = ws_create_glcontext(wnd->GetHandle(), msaaSamples, enableVSync, coreProfile, enableDebug, const_cast<OpenGL*>(&gl));
	MakeCurrentContext();
	init_caps();
	caps.LinearColorSpace = linearSpace;

	string uvendor = gl.Vendor.ToUpper();
	if(uvendor.Contains("NVIDIA"))
		vendor=GpuVendor::NVidia;
	else if(uvendor.Contains("INTEL"))
		vendor=GpuVendor::Intel;
	else if(uvendor.Contains("AMD") || uvendor.Contains("ATI"))
		vendor=GpuVendor::AMD;
	else if(uvendor.Contains("QUALCOMM"))
		vendor=GpuVendor::Qualcomm;
	else if(uvendor.Contains("IMAGINATION"))
		vendor=GpuVendor::Imagination;
	else if(uvendor.Contains("ARM") || uvendor.Contains("MALI"))
		vendor=GpuVendor::ARM;
	else if(uvendor.Contains("MESA"))
		vendor=GpuVendor::Mesa;
	else
		vendor=GpuVendor::Unknown;



	common_shader_code_addin_start = "#version "+ToString(gl.GLSLVersion);
	
	if(gl.GLES) common_shader_code_addin_start += " es";
	else if(gl.IsCoreContext && gl.GLSLVersion>=300) common_shader_code_addin_start += " core";
	common_shader_code_addin_start+="\r\n";

	string glslExtensions, glslDefines;

	StringView def;
	if(caps.HardwareInstancing)
	{
		if(gl.Version<30 || !gl.GLES && gl.Version<31)
		{
			string ext;
			if(gl.Extensions.Contains("GL_ARB_draw_instanced ")) ext="ARB";
			else if(gl.Extensions.Contains("GL_EXT_draw_instanced ")) ext="EXT";
			else if(gl.Extensions.Contains("GL_NV_draw_instanced ")) ext="NV";
			glslExtensions += "#extension GL_"+ext+"_draw_instanced: enable\r\n";
		}
		def = "#define InstanceID gl_InstanceID\r\n";
	}
	else def = "uniform int InstanceID;\r\n"; //Для эмуляции инстансинга
	shader_code_addins[0]+=def;
	shader_code_addins[2]+=def;

	if(gl.Caps.explicit_attrib_location)
	{
		if(gl.GLES && gl.Version<30 || gl.Version<33)
			if(gl.Extensions.Contains("GL_ARB_explicit_attrib_location "))
			{
				glslExtensions+="#extension GL_ARB_explicit_attrib_location: enable\r\n";
			}
	}
	//else common_shader_code_addin_start+="#define layout(location)\r\n"; //Выкинем, надеясь, что это ни на что не повлияет. В будущем сделать парсинг и gl.BindFragDataLocation (GL 3.0+) и др.
	if(gl.GLSLVersion==100 && gl.Extensions.Contains("GL_OES_standard_derivatives "))
	{
		shader_code_addins[1]+="#extension GL_OES_standard_derivatives: enable\r\n";
	}

	if(!gl.GLES && gl.GLSLVersion>=130 || gl.GLSLVersion>=300) //Новые версии OpenGL жалуются на устаревшие ключевые слова, поэтому заменим их на современные
	{
		shader_code_addins[0]+="#define varying out\r\n"
			"#define attribute in\r\n";
		shader_code_addins[1]+="#define varying in\r\n";
		glslDefines += 
			"#define texture1D texture\r\n"
			"#define texture1DLod textureLod\r\n"
			"#define texture1DProj textureProj\r\n"
			"#define texture1DProjLod textureProjLod\r\n"

			"#define texture2D texture\r\n"
			"#define texture2DLod textureLod\r\n"
			"#define texture2DProj textureProj\r\n"
			"#define texture2DProjLod textureProjLod\r\n";

		if(!gl.GLES) glslDefines += 
			"#define textureCube texture\r\n"
			"#define textureCubeLod textureLod\r\n"

			"#define texture3D texture\r\n"
			"#define texture3DLod textureLod\r\n"
			"#define texture3DProj textureProj\r\n"
			"#define texture3DProjLod textureProjLod\r\n"
			
			"#define shadow1D texture\r\n"
			"#define shadow1DLod textureLod\r\n"
			"#define shadow1DProj textureProj\r\n"
			"#define shadow1DProjLod textureProjLod\r\n"

			"#define shadow2D texture\r\n"
			"#define shadow2DLod textureLod\r\n"
			"#define shadow2DProj textureProj\r\n"
			"#define shadow2DProjLod textureProjLod\r\n";
	}
	else
	{
		if(gl.Extensions.Contains("GL_EXT_shadow_samplers "))
		{
			glslExtensions += "#extension GL_EXT_shadow_samplers: enable\r\n";
			glslDefines += "#define shadow2D shadow2DEXT\r\n"
				"#define shadow2DProj shadow2DProjEXT\r\n"
				"float texture(sampler2DShadow s, vec3 texcoord) {return shadow2DEXT(s, texcoord);}"
				"float texture(sampler2DShadow s, vec4 texcoord) {return shadow2DProjEXT(s, texcoord);}";
		}

		glslDefines+=
			"vec4 texture(sampler2D s, vec2 texcoord) {return texture2D(s, texcoord);}\r\n"
			"vec4 texture(sampler3D s, vec3 texcoord) {return texture3D(s, texcoord);}\r\n"
			"vec4 texture(samplerCube s, vec3 texcoord) {return textureCube(s, texcoord);}\r\n";
	}

	if(gl.Version>=30 || !gl.GLES)
		shader_code_addins[0] += "#define VertexID gl_VertexID\r\n";
	else
		shader_code_addins[0] += "attribute int VertexID;\n"; //Для GLES 2.0 нужно передавать вручную


	//Эмуляция новых функций для старого GLSL
	if(gl.GLSLVersion<130)
	{
		glslDefines+=
			"float trunc(float x) {return sign(x)*floor(abs(x));}\r\n"
			"vec2 trunc(vec2 x) {return sign(x)*floor(abs(x));}\r\n"
			"vec3 trunc(vec3 x) {return sign(x)*floor(abs(x));}\r\n"
			"vec4 trunc(vec4 x) {return sign(x)*floor(abs(x));}\r\n";
	}
	if(gl.Caps.uniform_buffer_object)
		glslDefines += "layout(std140) uniform;\r\n#define ubuffer uniform\r\n";

	//Добавляем для совместимости с HLSL
	glslDefines+="#define float2 vec2\r\n"
		"#define float3 vec3\r\n"
		"#define float4 vec4\r\n"

		"float saturate(float v) {return clamp(v, 0.0, 1.0);}\r\n"
		"vec2 saturate(vec2 v) {return clamp(v, 0.0, 1.0);}\r\n"
		"vec3 saturate(vec3 v) {return clamp(v, 0.0, 1.0);}\r\n"
		"vec4 saturate(vec4 v) {return clamp(v, 0.0, 1.0);}\r\n"

		//fmod из HLSL отличается от mod при отрицательных x/y
		"float fmod(float x, float y) {return x-y*trunc(x/y);}\r\n"
		"vec2 fmod(vec2 x, vec2 y) {return x-y*trunc(x/y);}\r\n"
		"vec3 fmod(vec3 x, vec3 y) {return x-y*trunc(x/y);}\r\n"
		"vec4 fmod(vec4 x, vec4 y) {return x-y*trunc(x/y);}\r\n";

	if(gl.GLSLVersion>=330) glslDefines += 
		"#define f32tof16 f32tof16_\r\n"
		"uint f32tof16_(float v) {return packHalf2x16(vec2(v, 0)) & 0xFFFF;}\r\n"
		"uvec2 f32tof16_(vec2 v) {uint result = packHalf2x16(v); return uvec2(result & 0xFFFF, result >> 16);}\r\n"
		"uvec3 f32tof16_(vec3 v) {return uvec3(f32tof16(v.xy), f32tof16(v.z));}\r\n"
		"uvec4 f32tof16_(vec4 v) {return uvec4(f32tof16(v.xy), f32tof16(v.zw));}\r\n"

		"#define f16tof32 f16tof32_\r\n"
		"float f16tof32_(uint v) {return unpackHalf2x16(v).x;}\r\n"
		"vec2 f16tof32_(uvec2 v) {return unpackHalf2x16((v.x & 0xFFFF)|(v.y << 16));}\r\n"
		"vec3 f16tof32_(uvec3 v) {return vec3(f16tof32(v.xy), f16tof32(v.z));}\r\n"
		"vec4 f16tof32_(uvec4 v) {return vec4(f16tof32(v.xy), f16tof32(v.zw));}\r\n";


	common_shader_code_addin_start += glslExtensions;
	common_shader_code_addin_start += glslDefines;

	common_shader_code_addin_end+="#line 1\n";



#ifndef _NO_LOGGING
	if(enableDebug && gl.Caps.debug_output)
	{
		gl.DebugMessageCallback(GL_debug_output_callback, this);

#ifdef _DEBUG
		gl.Enable(GL::DEBUG_OUTPUT_SYNCHRONOUS);
#endif

	}
#endif

	//Инициализация состояний OpenGL
	gl.DepthFunc(GL::LEQUAL);

	//Правильно устанавливаем текущее состояние, чтобы правильно работало отслеживание состояний
	RenderState& st = current_state.render_states;
	st.PolygonMode=PolyMode::Fill;
	st.SrcBlend=BlendFactor::One;
	st.DstBlend=BlendFactor::Zero;
	st.BlendEnabled=false;
	st.DepthWriteEnabled=true;
	st.DepthTestEnabled=false;
	st.AlphaToCoverageEnabled=false;
	st.CullBackFaces=false;

	if(gl.Caps.vertex_array_object)
	{
		gl.GenVertexArrays(1, &empty_vao);
	}
	gl.GenFramebuffers(1, &tempFBO0);

	if(!gl.IsCoreContext) gl.Enable(GL::POINT_SPRITE); //В compatibility point sprites не работают без этого состояния, а в core оно устарело
	gl.Enable(GL::PROGRAM_POINT_SIZE);
	if(gl.Caps.framebuffer_srgb && linearSpace) gl.Enable(GL::FRAMEBUFFER_SRGB);

	if(uniformTypeFromGL==null)
	{
		for(ushort i=1; i<UniformType::End; i++)
		{
			const auto t=(ushort)uniformTypeToGLType(UniformType(i));
			if(t!=0) uniformTypeFromGL[t]=UniformType(i);
		}
	}

	default_sampler = SamplerCreate(SamplerDesc());
	

	//Инициализируем всё что нужно для рисования квада на экран\в текстуру. Это понадобится для масштабирования и конвертирования текстур
	string log;
	ShaderObject* vertobj = ShaderObjectCreate(
		"uniform vec2 offset, size, tcStart, tcEnd; uniform float DrawDepth=1.0;\r\n"
		"varying vec2 TexCoord;\r\n"
		"void main() {\r\n"
			"mat4x2 quadVertexPositions = mat4x2(-1.0, -1.0,  1.0, -1.0,  -1.0, 1.0,  1.0, 1.0);\r\n"
			"vec2 position = quadVertexPositions[VertexID];\r\n"
			"gl_Position = vec4((offset+position*size)*2.0-1.0, DrawDepth, 1.0);\r\n"
			"TexCoord = tcStart+position*(tcEnd-tcStart);\r\n"
		"}", ShaderType::Vertex, ShaderLang::GLSL, &log);
	if(log!=null) Console << log;
	
	ShaderObject* fragobj = ShaderObjectCreate(
		"layout(location=0) out vec4 Result;\r\n"
		"varying vec2 TexCoord;\r\n"
		"uniform sampler2D tex;\r\n"
		"void main() {\r\n"
			"Result=texture(tex, TexCoord);\r\n"
		"}", ShaderType::Fragment, ShaderLang::GLSL, &log);
	if(log!=null) Console << log;

	screen_quad_sh = ShaderLink(vertobj, fragobj, null, null, null,  null, &log);
	ShaderObjectDelete(vertobj);
	ShaderObjectDelete(fragobj);
}

void GraphicsGL::init_caps()
{
	int cap;

	//const_cast<bool&>(gl.Caps.vertex_array_object)=false;

	gl.GetIntegerv(GL::MAX_COMBINED_TEXTURE_IMAGE_UNITS, &cap);
	caps.MaxTextures = (ushort)cap;

	gl.GetIntegerv(GL::MAX_VERTEX_TEXTURE_IMAGE_UNITS, &cap);
	caps.MaxVertexTextures = (ushort)cap;

	gl.GetIntegerv(GL::MAX_TEXTURE_IMAGE_UNITS, &cap);
	caps.MaxFragmentTextures = (ushort)cap;

	gl.GetIntegerv(GL::MAX_TEXTURE_SIZE, &cap);
	caps.MaxTexture2DSize = (ushort)cap;

	caps.Texture3D = gl.Caps.texture_3D;
	if(caps.Texture3D)
	{
		gl.GetIntegerv(GL::MAX_3D_TEXTURE_SIZE, &cap);
		caps.MaxTexture3DSize = (ushort)cap;
	}
	else caps.MaxTexture3DSize=0;

	caps.TextureArray = gl.Caps.texture_array;
	if(caps.TextureArray)
	{
		gl.GetIntegerv(GL::MAX_ARRAY_TEXTURE_LAYERS, &cap);
		caps.MaxTextureArraySizeAndCount = (ushort)cap;
	}
	else caps.MaxTextureArraySizeAndCount = 0;
	
	//Текстуры глубины
	caps.TextureDepth16 = gl.Caps.texture_depth16;
	caps.TextureDepth24 = gl.Caps.texture_depth24;
	caps.TextureDepth32 = gl.Caps.texture_depth32,
	caps.DepthShadow = gl.Caps.texture_depth_comparison_modes;
	caps.TextureDepth32F = gl.Caps.texture_depth32f;
	caps.TextureCubeDepth = gl.Caps.depth_cube_map;
	caps.TextureDepthStencil = gl.Caps.texture_d24s8;

	//Форматы с плавающей запятой
	caps.TextureFloat16 = gl.Caps.texture_half_float;
	caps.TextureFloat32 = gl.Caps.texture_float;
	caps.TextureFloat16Filtering = gl.Caps.texture_half_float_linear;
	caps.TextureFloat32Filtering = gl.Caps.texture_float_linear;
	caps.TextureFloat16Rendering = gl.Caps.color_buffer_half_float;
	caps.TextureFloat32Rendering = gl.Caps.color_buffer_float;
	caps.TextureInteger16 = caps.TextureInteger32 = gl.Caps.texture_integer;

	//Сжатые форматы
	caps.TextureLATC = gl.Caps.texture_latc || (gl.Caps.texture_rgtc || gl.Caps.texture_3dc) && gl.Caps.texture_swizzle;
	caps.TextureRGTC = gl.Caps.texture_rgtc || gl.Caps.texture_3dc;
	caps.TextureDXT1 = gl.Caps.texture_s3tc || gl.Caps.texture_dxt1;
	caps.TextureDXT3 = gl.Caps.texture_s3tc || gl.Caps.texture_dxt3;
	caps.TextureDXT5 = gl.Caps.texture_s3tc || gl.Caps.texture_dxt5;
	caps.TextureETC1 = gl.Caps.texture_etc1;
	caps.TextureETC2 = gl.Caps.texture_etc2;

	gl.GetIntegerv(GL::MAX_COLOR_ATTACHMENTS, &cap);
	caps.MaxColorAttachments = (ushort)cap;

	caps.MaxAnisotropy = 1;
	if(gl.Caps.texture_filter_anisotropic)
	{
		gl.GetIntegerv(GL::MAX_TEXTURE_MAX_ANISOTROPY, &cap);
		caps.MaxAnisotropy = (ushort)cap;
	}

	caps.TextureRed = caps.TextureRG = gl.Caps.texture_rg;
	caps.TextureBGRA = gl.Caps.texture_bgra;

	caps.IsDebugContext = gl.Caps.debug_output;
	caps.TextureSwizzle = gl.Caps.texture_swizzle;
	caps.HardwareInstancing = gl.Caps.draw_instanced;
	caps.GeometryShader = gl.Caps.geometry_shader;
	caps.ShaderDynamicLinkage = gl.Caps.shader_subroutine;
	caps.TessellationShader = gl.Caps.tessellation_shader;

	caps.HardwareIntegers = gl.Caps.texture_integer;

#if(EGL)
		int range[2];
		int mantissaBits;
		gl.GetShaderPrecisionFormat(GL::FRAGMENT_SHADER, GL::HIGH_FLOAT, range, &mantissaBits);
		if(range[0]==0 && range[1]==0 && mantissaBits==0)
			gl.GetShaderPrecisionFormat(GL::FRAGMENT_SHADER, GL::MEDIUM_FLOAT, range, &mantissaBits);
		caps.ShaderFloatMantissaBits = (ushort)mantissaBits;
		caps.ShaderIntegerBits = caps.HardwareIntegers? 32: caps.ShaderFloatMantissaBits;
#else
	caps.ShaderFloatMantissaBits = byte(gl.Caps.gpu_shader_fp64? 52: 23);
	caps.ShaderIntegerBits = byte(caps.HardwareIntegers? 32: 23);
#endif

	caps.MapBuffer = (gl.Caps.map_buffer || gl.Caps.map_buffer_range);
	caps.Index32Bit = gl.Caps.element_index_uint;
	caps.CopyBuffer = gl.Caps.copy_buffer;
	caps.FastCopyTexture = (byte)gl.Caps.copy_image;
	caps.BufferTextureCopy = (gl.Version>=21 || gl.Extensions.Contains("GL_ARB_pixel_buffer_object "));
	if(gl.Version>=43 || gl.Extensions.Contains("GL_ARB_copy_image ")) caps.FastCopyTexture=2;

	caps.DrawIndexedFirstVertex = gl.Caps.draw_elements_base_vertex;
}

GraphicsGL::~GraphicsGL()
{
	CleanUp();
}

void GraphicsGL::CleanUp()
{
	OnDestroy(this);

	while(created_framebuffers!=null) FramebufferDelete(created_framebuffers[0]);
	while(created_textures!=null) TextureDelete(created_textures[0]);
	while(created_shader_objects!=null) ShaderObjectDelete(created_shader_objects[0]);
	while(created_shaders!=null) ShaderDelete(created_shaders[0]);
	while(created_vertex_attrib_states!=null) VertexAttribStateDelete(created_vertex_attrib_states[0]);
	while(created_buffers!=null) BufferViewDelete(created_buffers[0]);

	auto wndHandle=OwnerWindow()->GetHandle();
	if(wndHandle!=null) ws_delete_glcontext(wndHandle);
	context=null;
}

//Получить текущий контекст OpenGL
GLContextHandle GraphicsGL::GetCurrentContext() {return null;} //TODO implement

//Сделать этот контекст текущим
void GraphicsGL::MakeCurrentContext()
{
	OwnerWindow()->make_current();
}

//Функции рендеринга:

//Очистить окно цветом Color
void GraphicsGL::Clear(const vec4& color, ClearFlags flags)
{
	if(flags & ClearFlags_Color)
		gl.ClearColor(color.x, color.y, color.z, color.w);

	if(flags & ClearFlags_Depth)
		gl.DepthMask(true);

	uint bits = 0;

	if(flags & ClearFlags_Color)
		bits |= GL::COLOR_BUFFER_BIT;

	if(flags & ClearFlags_Depth)
		bits |= GL::DEPTH_BUFFER_BIT;

	gl.Clear(bits);
}

//Закончить рисование текущего кадра
void GraphicsGL::EndFrame()
{
#ifndef NO_ERROR_CHECKING
#ifndef _NO_LOGGING
	string errors;
	while(GLenum err = gl.GetError())
		errors += string::Format("0x<^> ")(err, 4, '0', 16);
	if(errors!=null && ErrorLog)
	{
		ErrorLog.PushStyle("error");
		ErrorLog << string::Format("Ошибки OpenGL за кадр <^>: <^>")(FrameNumber)(errors);
		ErrorLog.PopStyle();
		ErrorLog << endl;
	}
#endif
#endif
	FrameNumber++;
	OwnerWindow()->swap_buffers();
}




AGraphics::MemoryBlock* GraphicsGL::MemoryAllocate(uint bytes, MemoryFlags flags)
{
	return new MemoryBlock{flags, bytes};
}

void GraphicsGL::MemoryFree(MemoryBlock* block)
{
	delete block;
}


//Параметры должны удовлетворять одному из следующих условий:
// 1) dataMips.Count()==1. В этом случае указанное число мип-уровней (или все, если указано 0) будут сгенерированы автоматически, если это возможно
// 2) dataMips==null, desc.mipmaps - любое. Текстура создаётся пустой. При будущем обновлении будут сгенерированы все мип-уровни или указанное их число
// 3) dataMips.Count()==desc.mipmaps. Все мип-уровни задаются вручную.
//Если какой-то из элементов dataMips[i]==null, то i-й мип-уровень останется неинициализированным и должен быть установлен позже.
AGraphics::Texture* GraphicsGL::TextureAllocate(const ImageInfo& desc, bool autoGenMipmaps)
{
	assert(!autoGenMipmaps || !desc.Format.IsCompressed() &&
		!desc.Format.IsIntegral() && !desc.Format.HasDepth() && !desc.Format.HasStencil());

	const GLenum gl_Target = ImageTypeToGLTarget(desc.Type);
	GLenum gl_InternalFormat = ImageFormatToGLInternal(desc.Format, caps.TextureSwizzle);
	const bool compressed = desc.Format.IsCompressed();

	//Для поддержки RGTC на мобильных платформах
	if(compressed && !gl.Caps.texture_rgtc && gl.Caps.texture_3dc)
	{
		if(gl_InternalFormat==GL::COMPRESSED_RED_RGTC1)
			gl_InternalFormat=GL::_3DC_X_AMD;
		else if(gl_InternalFormat==GL::COMPRESSED_RG_RGTC2)
			gl_InternalFormat=GL::_3DC_XY_AMD;
	}

	const GLenum gl_ExternalFormat = ImageFormatToGLExternal(
		compressed? desc.Format.GetBasicFormat(): desc.Format, false, caps.TextureSwizzle);
	const GLenum gl_Type = ImageFormatToGLType(compressed? desc.Format.GetBasicFormat(): desc.Format);
	assert(gl_Type!=0 && gl_ExternalFormat!=0 || compressed);

#ifndef NO_ERROR_CHECKING
	while(gl.GetError()!=GL::NO_ERROR);
#endif

	auto tex = new Texture{0, desc};
	ushort maxMipCount = desc.CalculateMaxMipmapCount();
	if(tex->info.MipmapCount==0 || tex->info.MipmapCount>maxMipCount)
		tex->info.MipmapCount = maxMipCount;

	gl.GenTextures(1, &tex->id);
	if(active_texture_slot!=0)
	{
		gl.ActiveTexture(GL::TEXTURE0);
		active_texture_slot = 0;
	}
	bound_textures[0] = tex;
	gl.BindTexture(gl_Target, tex->id);

	if(!gl.Caps.texture_storage)
	{
		gl.TexParameteri(gl_Target, GL::TEXTURE_BASE_LEVEL, 0);
		gl.TexParameteri(gl_Target, GL::TEXTURE_MAX_LEVEL, tex->info.MipmapCount-1);
		if(bound_pixel_unpack_buf!=null)
		{
			gl.BindBuffer(GL::PIXEL_UNPACK_BUFFER, 0);
			bound_pixel_unpack_buf=null;
		}
	}

	if(desc.Type==ImageType_Cube)
	{
		assert(desc.Size.x==desc.Size.y && desc.Size.z==6);
#ifndef MINIMIZE_GL
		if(gl.Caps.texture_storage)
		{
#ifndef NO_ERROR_CHECKING
			if(Vendor()==GpuVendor::AMD) //Сбрасываем все предыдущие ошибки для обнаружения известного бага AMD в драйверах 11.x-12.x
				while(gl.GetError()!=GL::NO_ERROR);
#endif
			gl.TexStorage2D(gl_Target, tex->info.MipmapCount, gl_InternalFormat, desc.Size.x, desc.Size.y);
		}
		else
#endif	
			for(ushort mip=0; mip<tex->info.MipmapCount; mip++)
		{
			for(ushort side=0; side<6; side++)
				gl.TexImage2D(CubeFaceToGLTarget(CubeFace(side)), 0, (int)gl_InternalFormat,
					desc.Size.x >> mip, desc.Size.x >> mip, 0, gl_ExternalFormat, gl_Type, null);
		}

		static const ushort wrap[] = {GL::TEXTURE_WRAP_S, GL::TEXTURE_WRAP_T, GL::TEXTURE_WRAP_R};
		for(byte i=0; i<3; i++)
			gl.TexParameteri(GL::TEXTURE_CUBE_MAP, wrap[i], GL::CLAMP_TO_EDGE);
	}
	else if(desc.Type==ImageType_2D)
	{
#ifndef MINIMIZE_GL
		if(gl.Caps.texture_storage)
			gl.TexStorage2D(gl_Target, tex->info.MipmapCount, gl_InternalFormat, desc.Size.x, desc.Size.y);
		else
#endif
		{
			for(ushort i=0; i<tex->info.MipmapCount; i++)
			{
				const auto mipSize = desc.CalculateMipmapSize(i);
				gl.TexImage2D(gl_Target, i, (int)gl_InternalFormat, mipSize.x, mipSize.y, 0, gl_ExternalFormat, gl_Type, null);
			}
		}
	}
	else if(desc.Type==ImageType_3D || desc.Type==ImageType_2DArray)
	{
		if(gl.Caps.texture_storage)
			gl.TexStorage3D(gl_Target, tex->info.MipmapCount, gl_InternalFormat, desc.Size.x, desc.Size.y, desc.Size.z);
		else for(ushort i=0; i<tex->info.MipmapCount; i++)
			gl.TexImage3D(gl_Target, i, (int)gl_InternalFormat,
				desc.Size.x, desc.Size.y, desc.Size.z, 0, gl_ExternalFormat, gl_Type, null);
	}
	else assert(!"Unknown texture type!");

	if(autoGenMipmaps) tex->mipstate = MipmapState::AutoGenerate;
	else tex->mipstate = MipmapState::Manual;

	if(caps.TextureSwizzle && !desc.Format.HasColor() && !desc.Format.HasDepth())
	{
		int values[4] = {GL::RED, GL::RED, GL::RED, GL::RED};
		if(desc.Format.IsLuminance()) values[3] = GL::ONE;
		else if(desc.Format.IsAlpha()) values[0] = values[1] = values[2] = GL::ZERO;
		else if(desc.Format.HasLuminance() && desc.Format.HasAlpha()) values[3] = GL::GREEN;
		else values[0] = 0;
		if(values[0] != 0) gl.TexParameteriv(gl_Target, GL::TEXTURE_SWIZZLE_RGBA, values);
	}

#ifndef NO_ERROR_CHECKING
	GLenum err = gl.GetError();
#ifndef _NO_LOGGING
	if(!gl.Caps.debug_output || !gl.IsDebugContext)
	{
		if(err!=GL::NO_ERROR) //Если произошла хоть одна ошибка
		{
			ErrorLog.PushStyle("error");
			ErrorLog << endl << "Ошибка создания текстуры "+texture_ToString(tex, caps.TextureSwizzle) << endl;
			ErrorLog.PopStyle();
		}
	}
	if(err==GL::NO_ERROR)
	{
		InfoLog.PushStyle("info");
		InfoLog << "Создана текстура " << tex->id << "." << endl;
		InfoLog.PopStyle();
	}
#endif

	if(err!=GL::NO_ERROR)
	{
		gl.DeleteTextures(1, &tex->id);
		delete tex;
		return null;
	}
#endif

	created_textures.AddLast(tex);
	return tex;
}

ImageInfo GraphicsGL::TextureGetInfo(AGraphics::Texture* tex) {return tex->info;}

void GraphicsGL::TextureSetData(AGraphics::Texture* dst, uint mipLevel, usvec3 dstOffset,
	usvec3 srcSize, ImageFormat srcFmt, const void* srcData, bool swapRB, uint lineAlignment)
{
	assert(dst!=null);
	assert(mipLevel < dst->info.MipmapCount);
	const auto mipSize = CalculateMipmapSize(dst->info.Size, dst->info.Type, mipLevel);
	assert(dstOffset.x+srcSize.x<=mipSize.x && dstOffset.y+srcSize.y<=mipSize.y && dstOffset.z+srcSize.z<=mipSize.z);

	const GLenum gl_Target = ImageTypeToGLTarget(dst->info.Type);
	const uintptr faceSize = uintptr( srcSize.x*srcSize.y*srcFmt.BytesPerPixel() );
	const bool compressed = srcFmt.IsCompressed();
	const GLenum gl_ExternalFormat = GLenum( compressed? 0: ImageFormatToGLExternal(srcFmt, swapRB, caps.TextureSwizzle) );
	const GLenum gl_Type = ImageFormatToGLType(srcFmt);

	if(active_texture_slot!=0)
		gl.ActiveTexture(GL::TEXTURE0), active_texture_slot=0;

	if(bound_textures[0]!=dst)
	{
		bound_textures[0]=dst;
		gl.BindTexture(gl_Target, dst->id);
	}

	gl.PixelStorei(GL::UNPACK_ALIGNMENT, lineAlignment);
	if(bound_pixel_unpack_buf!=current_pixel_unpack_buf)
	{
		bound_pixel_unpack_buf=current_pixel_unpack_buf;
		gl.BindBuffer(GL::PIXEL_UNPACK_BUFFER, bound_pixel_unpack_buf==null? 0: bound_pixel_unpack_buf->id);
	}

	if(dst->info.Type==ImageType_2D || dst->info.Type==ImageType_Cube)
	{
		if(!compressed)
		{
			for(ushort i=0; i<srcSize.z; i++)
				gl.TexSubImage2D(convertToGLTarget(dst, ushort(dstOffset.z+i)), (int)mipLevel, dstOffset.x, dstOffset.y,
					srcSize.x, srcSize.y, gl_ExternalFormat, gl_Type, (const byte*)srcData+i*faceSize);
		}
		else
		{
			ImageInfo srcRectInfo = {srcSize, srcFmt, dst->info.Type, dst->info.MipmapCount};
			const int dataSize = (int)srcRectInfo.CalculateMipmapDataSize(0, lineAlignment);
			auto gl_InternalFormat = ImageFormatToGLInternal(srcFmt, caps.TextureSwizzle);
			if(compressed && !gl.Caps.texture_rgtc && gl.Caps.texture_3dc) //Для поддержки RGTC на мобильных платформах
			{
				if(gl_InternalFormat==GL::COMPRESSED_RED_RGTC1)
					gl_InternalFormat=GL::_3DC_X_AMD;
				else if(gl_InternalFormat==GL::COMPRESSED_RG_RGTC2)
					gl_InternalFormat=GL::_3DC_XY_AMD;
			}
			for(ushort z=0; z<srcSize.z; z++)
			{
				gl.CompressedTexSubImage2D(convertToGLTarget(dst, ushort(dstOffset.z+z)), (int)mipLevel, dstOffset.x, dstOffset.y,
					srcSize.x, srcSize.y, gl_InternalFormat, dataSize, (const byte*)srcData+z*faceSize);
			}
		}
	}
	else if(dst->info.Type==ImageType_3D || dst->info.Type==ImageType_2DArray)
	{
		gl.TexSubImage3D(gl_Target, (int)mipLevel, dstOffset.x, dstOffset.y, dstOffset.z,
			srcSize.x, srcSize.y, srcSize.z, gl_ExternalFormat, gl_Type, srcData);
	}
	else assert(!"Unknown texture type!");

	if(dst->mipstate==MipmapState::AutoGenerate)
		dst->mipstate=MipmapState::AutoGenerateDirty;
}

void GraphicsGL::TextureGenerateMipmaps(AGraphics::Texture* tex)
{
	if(tex==null) return;
	if(tex->mipstate!=MipmapState::Manual)
	{
		tex->mipstate = MipmapState::AutoGenerateDirty;
		return;
	}
	const auto gl_Target = ImageTypeToGLTarget(tex->info.Type);
	if(active_texture_slot!=0)
	{
		gl.ActiveTexture(GL::TEXTURE0);
		active_texture_slot = 0;
	}
	if(bound_textures[0]!=tex)
	{
		bound_textures[0] = tex;
		gl.BindTexture(gl_Target, tex->id);
	}
	gl.GenerateMipmap(gl_Target);
}


void GraphicsGL::TextureDelete(AGraphics::Texture* tex)
{
	if(context==null || tex==null) return;
	assert(gl.IsTexture(tex->id));
	gl.DeleteTextures(1, &tex->id);

#ifndef _NO_LOGGING
	InfoLog.PushStyle("info");
	InfoLog << "Текстура " << tex->id << " удалена." << endl;
	InfoLog.PopStyle();
#endif

	created_textures.FindAndRemoveUnordered(tex);
	delete tex;
}

//При активном PBO данные возвращаются не в ОЗУ, а в буфер
void GraphicsGL::TextureGetData(AGraphics::Texture* src, uint mipLevel, usvec3 srcOffset,
	usvec3 dstSize, ImageFormat dstFmt, void* dstBuffer, bool swapRB, uint lineAlignment)
{
	assert(src!=null);
	assert(mipLevel<src->info.MipmapCount);
	const auto mipSize = max(usvec3(1), usvec3(src->info.Size.x >> mipLevel, src->info.Size.y >> mipLevel, src->info.Size.z >> (src->info.Type==ImageType_2DArray? 0: mipLevel)));
	assert(srcOffset.x+dstSize.x<=mipSize.x && srcOffset.y+dstSize.y<=mipSize.y && srcOffset.z+dstSize.z<=mipSize.z);
	assert(lineAlignment==1 || lineAlignment==2 || lineAlignment==4 || lineAlignment==8);

	byte* dstPos = (byte*)dstBuffer;
	const GLenum gl_Type = ImageFormatToGLType(dstFmt);
	const GLenum gl_Target = ImageTypeToGLTarget(src->info.Type);
	const GLenum gl_ExternalFormat = ImageFormatToGLExternal(dstFmt, swapRB, caps.TextureSwizzle);
	bool compressed = dstFmt.IsCompressed();
	const ushort dstBpp = dstFmt.BitsPerPixel();

	gl.PixelStorei(GL::PACK_ALIGNMENT, (int)lineAlignment);
	if(bound_pixel_pack_buf!=current_pixel_pack_buf)
	{
		bound_pixel_pack_buf = current_pixel_pack_buf;
		gl.BindBuffer(GL::PIXEL_PACK_BUFFER, bound_pixel_pack_buf==null? 0u: bound_pixel_pack_buf->id);
	}

	if(src->mipstate==MipmapState::AutoGenerateDirty && mipLevel>0)
	{
		src->mipstate=MipmapState::AutoGenerate;
		if(active_texture_slot!=0)
		{
			gl.ActiveTexture(GL::TEXTURE0);
			active_texture_slot=0;
		}
		if(bound_textures[0]!=src)
		{
			bound_textures[0]=src;
			gl.BindTexture(gl_Target, src->id);
		}
		gl.GenerateMipmap(ImageTypeToGLTarget(src->info.Type));
	}

#ifndef MINIMIZE_GL
	if(usvec2(srcOffset)==usvec2(0) && usvec2(dstSize)==usvec2(mipSize) &&
			(srcOffset.z==0 && dstSize.z==mipSize.z || src->info.Type==ImageType_Cube))
	{
		if(active_texture_slot!=0)
		{
			gl.ActiveTexture(GL::TEXTURE0);
			active_texture_slot=0;
		}
		if(bound_textures[0]!=src)
		{
			bound_textures[0]=src;
			gl.BindTexture(gl_Target, src->id);
		}
		for(ushort i=0, count=(src->info.Type==ImageType_Cube? dstSize.z: 1); i<count; i++)
		{
			const auto target = src->info.Type==ImageType_Cube? CubeFaceToGLTarget(CubeFace(srcOffset.z+i)): gl_Target;
			if(!compressed) gl.GetTexImage(target, mipLevel, gl_ExternalFormat, gl_Type, dstPos);
			else gl.GetCompressedTexImage(target, mipLevel, dstPos);
			dstPos += dstSize.x*dstSize.y*dstBpp/8;
		}
		return;
	}
#endif

	assert(src->info.Type!=ImageType_Cube && src->info.Type!=ImageType_3D &&
		src->info.Type!=ImageType_2DArray || srcOffset.z+dstSize.z<=mipSize.z);



	uint tempfbo;
	gl.GenFramebuffers(1, &tempfbo);
	gl.BindFramebuffer(GL::READ_FRAMEBUFFER, bound_read_fbo=tempfbo);

	for(ushort i=0; i<dstSize.z; i++)
	{
		if(src->info.Type==ImageType_2D || src->info.Type==ImageType_Cube)
		{
			auto texTarget = src->info.Type==ImageType_Cube? CubeFaceToGLTarget(CubeFace(srcOffset.z+i)): gl_Target;
			gl.FramebufferTexture2D(GL::READ_FRAMEBUFFER, GL::COLOR_ATTACHMENT0, texTarget, src->id, mipLevel);
		}
		else if(src->info.Type==ImageType_3D || src->info.Type==ImageType_2DArray)
			gl.FramebufferTexture3D(GL::READ_FRAMEBUFFER, GL::COLOR_ATTACHMENT0, gl_Target, src->id, mipLevel, srcOffset.z+i);
		gl.ReadPixels(srcOffset.x, srcOffset.y, dstSize.x, dstSize.y, gl_ExternalFormat, gl_Type, dstPos);
		dstPos += dstSize.x*dstSize.y*dstBpp/8;
	}
	gl.BindFramebuffer(GL::READ_FRAMEBUFFER, bound_read_fbo=current_read_fbo);
	gl.DeleteFramebuffers(1, &tempfbo);
}

//TODO: Добавить очистку мип-уровней
void GraphicsGL::Texture2DClear(Texture* tex, const vec4& color, usvec3 offset, usvec2 size)
{
	assert(tex!=null);

#ifndef MINIMIZE_GL
	if(gl.ClearTexImage!=null)
	{
		auto format = tex->info.Format;
		GLenum fmt = ImageFormatToGLExternal(format, false, gl.Caps.texture_swizzle);
		GLenum type = ImageFormatToGLType(format);
		assert(!format.IsCompressed() && "поддержка очистки текстур сжатых форматов не реализована!");
		
		Variable data;
		data.AsVec4 = color;
		data.ConvertType(data, ValueType::Vec4, format.GetValueType());
		for(uint i=0; i<tex->info.MipmapCount; i++)
			gl.ClearTexImage(tex->id, i, fmt, type, &data);
	}
#endif

	uint tempfbo;
	gl.GenFramebuffers(1, &tempfbo);
	gl.BindFramebuffer(GL::DRAW_FRAMEBUFFER, bound_draw_fbo=tempfbo);
	gl.Viewport(offset.x, offset.y, size.x, size.y);

	for(ushort mip=0; mip<tex->info.MipmapCount; mip++)
	{
		setFramebufferTexture({tex, 0, mip}, 0, gl, GL::DRAW_FRAMEBUFFER);
		Clear(color, ClearFlags_Color);
	}

	//gl.BindFramebuffer(GL::DRAW_FRAMEBUFFER, bound_draw_fbo=current_draw_fbo);
	gl.Viewport(current_state.viewport_pos.x, current_state.viewport_pos.y, current_state.viewport_size.x, current_state.viewport_size.y);
	gl.DeleteFramebuffers(1, &tempfbo);

	if(tex->mipstate==MipmapState::AutoGenerate)
		tex->mipstate=MipmapState::AutoGenerateDirty;
}

#ifndef MINIMIZE_GL
static bool areFormatsCompatible(ImageFormat dstFormat, uint dstMipLevel,
	ImageFormat srcFormat, uint srcMipLevel, GpuVendor vendor, const DeviceCaps& caps)
{
	if(dstFormat == srcFormat) return true;
	if(caps.FastCopyTexture!=2) return false;
	
	//Более новая версия расширения (ARB), вошедшая в ядро позволяет копировать текстуры с разными форматами, если они совместимы
	const auto dstBpp = dstFormat.BitsPerPixel();
	const auto srcBpp = srcFormat.BitsPerPixel();
	if(!dstFormat.IsCompressed() && !srcFormat.IsCompressed()) //Проверяем совместимость по texture_view
	{
		if(dstBpp==srcBpp) return true;
		return false;
	}

	ImageFormat comprFormat, otherFormat;
	byte cbpp, obpp;
	if(dstFormat.IsCompressed())
	{
		comprFormat=dstFormat;
		otherFormat=srcFormat;
		cbpp=dstBpp;
		obpp=srcBpp;
	}
	else
	{
		comprFormat = srcFormat;
		otherFormat = dstFormat;
		cbpp = srcBpp;
		obpp = dstBpp;
	}

	//TODO: в OpenGL ES бывают и другие совместимые сжатые форматы
	if(!comprFormat.IsCompressedBC1_BC7())
		return false;

	//BC1-BC7 имеют свои группы совместимости, основанные на размерах
	//Форматы BC1-BC7 с блоками одного размера (в байтах) совместимы
	if(otherFormat.IsCompressedBC1_BC7() && cbpp==obpp)
		return true;

	//На Intel замечено, что ненулевые мипы копируются неправильно
	if(!otherFormat.IsCompressed() && cbpp*4*4==obpp)
		return (vendor!=GpuVendor::Intel || srcMipLevel==0 && dstMipLevel==0);

	return false;
}
#endif


void GraphicsGL::TextureCopyBitData(AGraphics::Texture* dst, uint dstMipLevel, usvec3 dstOffset, usvec3 dstSize,
	AGraphics::Texture* src, uint srcMipLevel, usvec3 srcOffset, usvec3 srcSize)
{
	if(dst==null) return;
	assert(src!=null);

	auto srcRectInfo = src->info;
	srcRectInfo.Size=srcSize;

	auto dstRectInfo = dst->info;
	dstRectInfo.Size=dstSize;

	const uintptr rectSizeInBytes = srcRectInfo.CalculateMipmapDataSize(0, 4);
	assert(rectSizeInBytes==dstRectInfo.CalculateMipmapDataSize(0, 4));

#ifndef MINIMIZE_GL
	//Если доступно расширение для быстрого копирования текстур, то воспользуемся им,
	//убедившись в том, что форматы совместимы для побитового копирования с точки зрения функции glCopyImageSubData
	if(caps.FastCopyTexture>0 && areFormatsCompatible(dst->info.Format, dstMipLevel, src->info.Format, srcMipLevel, vendor, caps))
	{
		const GLenum srcTarget=convertToGLTarget(src, srcOffset.z), dstTarget=convertToGLTarget(dst, dstOffset.z);
		if(src->info.Type==ImageType_Cube)
		{
			for(ushort i=0; i<srcSize.z; i++)
				gl.CopyImageSubData(src->id, GL::TEXTURE_CUBE_MAP, srcMipLevel, srcOffset.x, srcOffset.y, srcOffset.z+i,
					dst->id, GL::TEXTURE_CUBE_MAP, dstMipLevel, dstOffset.x, dstOffset.y, dstOffset.z+i,
					srcSize.x, srcSize.y, 1);
			return;
		}
		gl.CopyImageSubData(src->id, srcTarget, srcMipLevel, srcOffset.x, srcOffset.y, srcOffset.z,
			dst->id, dstTarget, dstMipLevel, dstOffset.x, dstOffset.y, dstOffset.z,
			srcSize.x, srcSize.y, srcSize.z);
		return;
	}
#endif

	//Побитовое копирование через промежуточный буфер VBO, если поддерживается pixel buffer object.
	//Так можно побитово копировать абсолютно любые форматы,
	//но это медленнее, чем предыдущий вариант, особенно на Intel
	if(caps.BufferTextureCopy)
	{
		BufferView* temp = get_temp_ingpu_buffer(rectSizeInBytes);
		BufferCopyFromTexture(src, srcMipLevel, srcOffset, srcSize, temp, 0, 4);
		BufferCopyToTexture(temp, 0, dst, dstMipLevel, dstOffset, dstSize, 4);
		return;
	}

#ifndef MINIMIZE_GL
	//Аналогично предыдущему, но промежуточный буфер находится в RAM
	//Это медленно, но должно поддерживаться везде
	void* data = Memory::Allocate(rectSizeInBytes);
	TextureGetData(src, srcMipLevel, srcOffset, srcSize, src->info.Format, data, false, 4);
	TextureSetData(dst, dstMipLevel, dstOffset, dstSize, dst->info.Format, data, false, 4);
	Memory::Free(data);
#endif
}

void GraphicsGL::TextureCopyData(AGraphics::Texture* dst, uint dstMipLevel, usvec3 dstOffset, usvec3 dstSize,
	AGraphics::Texture* src, uint srcMipLevel, usvec3 srcOffset, usvec3 srcSize)
{
	assert(dst!=null && src!=null);
	assert(dstMipLevel<dst->info.MipmapCount && srcMipLevel<src->info.MipmapCount);

	const auto srcMipSize = src->info.CalculateMipmapSize(srcMipLevel);
	const auto dstMipSize = src->info.CalculateMipmapSize(dstMipLevel);

	assert(srcOffset.x+srcSize.x<=srcMipSize.x && srcOffset.y+srcSize.y<=srcMipSize.y && srcOffset.z+srcSize.z<=srcMipSize.z);
	assert(dstOffset.x+dstSize.x<=dstMipSize.x && dstOffset.y+dstSize.y<=dstMipSize.y && dstOffset.z+dstSize.z<=dstMipSize.z);

	if(dst->mipstate==MipmapState::AutoGenerate)
		dst->mipstate=MipmapState::AutoGenerateDirty;

	//Проверяем, нужна ли дополнительная обработка или можно копировать побитово
	//TODO: ослабить это условие, так как уменьшение в 2,4,8... раз можно реализовать, копируя mipmap'ы
	bool blitOnly = (srcSize==dstSize && src->info.Format==dst->info.Format);

	if(blitOnly)
	{
		TextureCopyBitData(dst, dstMipLevel, dstOffset, dstSize, src, srcMipLevel, srcOffset, srcSize);
		return;
	}

#ifndef MINIMIZE_GL
	if(blitOnly)
	{
		gl.BindFramebuffer(GL::READ_FRAMEBUFFER, bound_read_fbo=tempFBO0);
		for(ushort i=0; i<dstSize.z; i++)
		{
			setFramebufferTexture({src, srcOffset.z, (ushort)srcMipLevel}, 0, gl, GL::READ_FRAMEBUFFER);
			const GLenum gl_Target = convertToGLTarget(dst, dstOffset.z+i);
			if(dst->info.Type==ImageType_2D || dst->info.Type==ImageType_Cube)
				gl.CopyTexSubImage2D(gl_Target, dstMipLevel, dstOffset.x, dstOffset.y, srcOffset.x, srcOffset.y, srcSize.x, srcSize.y);
			else if(dst->info.Type==ImageType_3D || dst->info.Type==ImageType_2DArray)
				gl.CopyTexSubImage3D(gl_Target, dstMipLevel, dstOffset.x, dstOffset.y, dstOffset.z+i, srcOffset.x, srcOffset.y, srcSize.x, srcSize.y);
		}
	}
	else //Здесь может проводиться конверсия из одного формата в другой и\или масштабирование
#endif
	{
		gl.BindFramebuffer(GL::DRAW_FRAMEBUFFER, bound_read_fbo=tempFBO0);
		assert(src->info.Type==ImageType_2D && "Пока поддерживаются расширенное копирование только из 2D текстуры!"); //TODO
		setFramebufferTexture({dst, dstOffset.z, (ushort)dstMipLevel}, 0, gl, GL::DRAW_FRAMEBUFFER);
		if(active_texture_slot!=0) gl.ActiveTexture(GL::TEXTURE0), active_texture_slot=0;
		current_state.textures[0]=src;
		DrawScreenQuad(vec2(dstOffset.x, dstOffset.y)/vec2(dst->info.Size.x, dst->info.Size.y),
				vec2(dstSize)/vec2(dst->info.Size.x, dst->info.Size.y),
				vec2(srcOffset.x, srcOffset.y)/vec2(src->info.Size.x, src->info.Size.y),
				vec2(srcSize)/vec2(src->info.Size.x, src->info.Size.y),
				src);
	}
	gl.Viewport(current_state.viewport_pos.x, current_state.viewport_pos.y,
		current_state.viewport_size.x, current_state.viewport_size.y);
}

AGraphics::Texture* GraphicsGL::TextureCopy(AGraphics::Texture* src)
{
	//Timer tim;
	const bool autoGenMips = (src->mipstate==MipmapState::AutoGenerate || src->mipstate==MipmapState::AutoGenerateDirty);
	Texture* result = TextureAllocate(src->info, autoGenMips);
	for(ushort i=0; i<(autoGenMips? 1: src->info.MipmapCount); i++)
		TextureCopyData(result, i, {0,0,0}, src->info.Size, src, i, {0,0,0}, src->info.Size);
	if(autoGenMips) result->mipstate=MipmapState::AutoGenerateDirty;
	//PerfClockLog << "Texture copying time: " << tim.GetTime()*1000 << " ms. Type: " << ToString(src->info.Type) <<
	//	", size = {" << src->info.size.x << ", " << src->info.size.y << ", " << src->info.size.z << "}, Format = " << src->info.Format.ToString() << ".\n";
	return result;
}

AGraphics::Texture* GraphicsGL::TextureBitCopy(AGraphics::Texture* src, const ImageInfo& desc)
{
	//Timer tim;
	const bool autoGenMips = (src->mipstate==MipmapState::AutoGenerate || src->mipstate==MipmapState::AutoGenerateDirty);
	Texture* result = TextureAllocate(desc, autoGenMips);
	auto mipCount = autoGenMips? 1: src->info.MipmapCount;
	for(ushort mip=0; mip<mipCount; mip++)
	{
		TextureCopyBitData(result, mip, {0,0,0}, result->info.CalculateMipmapSize(mip), src, mip, {0,0,0}, src->info.CalculateMipmapSize(mip));
	}
	if(autoGenMips) result->mipstate=MipmapState::AutoGenerateDirty;
	//PerfClockLog << "Texture bit copying time: " << tim.GetTime()*1000 << " ms. Type: " << ToString(src->info.Type) <<
	//	", SrcSize = {" << src->info.size.x << ", " << src->info.size.y << ", " << src->info.size.z <<
	//	"}, DstSize = {" << desc.size.x << ", " << desc.size.y << ", " << desc.size.z <<
	//	"}, SrcFormat = " << src->info.Format.ToString() << ", DstFormat = " << desc.Format.ToString() << ", MipCount = " << mipCount << "." << endl;
	return result;
}

struct AGraphics::Sampler
{
	SamplerDesc desc;
	uint id;
	uint refs;
};

AGraphics::Sampler* GraphicsGL::SamplerCreate(const SamplerDesc& desc)
{
	auto found = created_samplers.Find(desc);
	if(found!=-1)
	{
		auto val = created_samplers.Value(found);
		val->refs++;
		return val;
	}
	Sampler* result = new Sampler{desc, 0, 1};
#ifndef MINIMIZE_GL
	if(gl.Caps.sampler_objects)
	{
		gl.GenSamplers(1, &result->id);
		//GL::TEXTURE_BORDER_COLOR
		TexFilter mipFilter = desc.MipFilter, minFilter = desc.MinFilter;
		gl.SamplerParameteri(result->id, GL::TEXTURE_MIN_FILTER, convertMinFilter(minFilter, mipFilter));
		gl.SamplerParameteri(result->id, GL::TEXTURE_MAG_FILTER, texFilterConvertTable[(ushort)desc.MagFilter]);

		uint anisotropy=1;
		if(desc.MinFilter>=TexFilter::AnisotropicX2)
		{
			const uint selectedAnisotropy = 1u << (1 + ((byte)desc.MinFilter-(byte)TexFilter::AnisotropicX2));
			anisotropy = min(selectedAnisotropy, caps.MaxAnisotropy);
		}
		if(caps.MaxAnisotropy>1 && anisotropy>1)
			gl.SamplerParameteri(result->id, GL::TEXTURE_MAX_ANISOTROPY, (int)anisotropy);

		gl.SamplerParameteri(result->id, GL::TEXTURE_WRAP_S, texWrapConvertTable[(byte)desc.WrapS]);
		gl.SamplerParameteri(result->id, GL::TEXTURE_WRAP_T, texWrapConvertTable[(byte)desc.WrapT]);
		gl.SamplerParameteri(result->id, GL::TEXTURE_WRAP_R, texWrapConvertTable[(byte)desc.WrapR]);

		gl.SamplerParameterf(result->id, GL::TEXTURE_MIN_LOD, desc.MinMip);
		gl.SamplerParameterf(result->id, GL::TEXTURE_MAX_LOD, desc.MaxMip);
		gl.SamplerParameterf(result->id, GL::TEXTURE_LOD_BIAS, desc.MipBias);

		gl.SamplerParameteri(result->id, GL::TEXTURE_COMPARE_MODE, texCompareModeConvertTable[(byte)desc.DepthCompareMode]);
		gl.SamplerParameteri(result->id, GL::TEXTURE_COMPARE_FUNC, compareFuncConvertTable[(byte)desc.DepthCompareFunc]);

#ifndef _NO_LOGGING
		GLenum err = gl.GetError();
		if(!gl.Caps.debug_output || !gl.IsDebugContext)
		{
			if(err!=GL::NO_ERROR) //Если произошла хоть одна ошибка
			{
				ErrorLog.PushStyle("error");
				ErrorLog << endl << "Ошибка создания сэмплера" << endl;
				ErrorLog.PopStyle();
			}
		}
		if(err==GL::NO_ERROR)
		{
			InfoLog.PushStyle("info");
			InfoLog << "Создан семплер " << result->id << "." << endl;
			InfoLog.PopStyle();
		}
#endif
	}
#endif
	created_samplers.Append(desc, result);
	return result;
}

void GraphicsGL::SamplerDelete(AGraphics::Sampler* samp)
{
	if(context==null || samp==null) return;
	if(--samp->refs==0)
	{
		if(gl.Caps.sampler_objects) gl.DeleteSamplers(1, &samp->id);
		created_samplers.Remove(samp->desc);
		delete samp;
	}
}


AGraphics::ShaderObject* GraphicsGL::ShaderObjectCreate(StringView code, ShaderType type, ShaderLang language, string* compilationLog)
{
	assert(type<=ShaderType::TessEval);
	assert(language==ShaderLang::GLSL && "Другие языки кроме GLSL пока не поддерживаются!");

	static const ushort targetTable[]={GL::VERTEX_SHADER, GL::FRAGMENT_SHADER, GL::GEOMETRY_SHADER, GL::TESS_CONTROL_SHADER, GL::TESS_EVALUATION_SHADER};
	uint shaderId=gl.CreateShader(targetTable[(ushort)type]);

	string fullCode = common_shader_code_addin_start+shader_code_addins[(int)type]+common_shader_code_addin_end+code;
	auto fullCodeCStr = fullCode.CStr();

	gl.ShaderSource(shaderId, 1, &fullCodeCStr, null);
	gl.CompileShader(shaderId);

#ifndef NO_ERROR_CHECKING
	string log;
	int infoLogLength; gl.GetShaderiv(shaderId, GL::INFO_LOG_LENGTH, &infoLogLength);
	if(infoLogLength!=0)
	{
		auto infobuf = Memory::Buffer::Allocate(infoLogLength+1);
		gl.GetShaderInfoLog(shaderId, infoLogLength, null, (char*)infobuf->Data);
		log = string(infobuf.ptr, (char*)infobuf->Data, (char*)infobuf->Data+infoLogLength-1);
		log = log.Trim();
		if(!log.Contains("warn") && !log.Contains("Warn") && !log.Contains("WARN") &&
			!log.Contains("error") && !log.Contains("Error") && !log.Contains("ERROR") || log=="No errors.")
			log=null;
	}
	if(compilationLog!=null) *compilationLog=log;

	int success; gl.GetShaderiv(shaderId, GL::COMPILE_STATUS, &success);
	if(!success)
	{
		gl.DeleteShader(shaderId);
		shaderId=0;
	}

#ifndef _NO_LOGGING
	auto printLogger=&InfoLog;
	if(log!=null)
	{
		if(!success) printLogger=&ErrorLog;
		else printLogger=&WarnLog;
		if(*printLogger)
		{
			//Вывод текста об ошибке
			printLogger->PushStyle(success? StringView("warn"): StringView("error"));
			*printLogger << endl << "Проблемы при компиляции шейдера:" << endl << log << endl;
			printLogger->PopStyle();
		}
	}

	if(*printLogger) if(!success && ShaderCodeLogging>=LogDetail::OnError ||
		log!=null && ShaderCodeLogging>=LogDetail::OnWarning ||
		ShaderCodeLogging==LogDetail::Always)
	{
		//Вывод исходного кода под спойлером
		printLogger->BeginSpoiler("Исходный код шейдера", "Скрыть код");
		printLogger->Print(fullCode);
		printLogger->EndSpoiler();
		*printLogger << endl;
	}

	if(shaderId!=0 && InfoLog)
	{
		InfoLog.PushStyle("info");
		static const StringView typeNames[]={"вершинный", "фрагментный", "геометрический", "tess control", "tess evaluation"};
		InfoLog << string::Format("Создан <^> шейдер <^>!")(typeNames[(ushort)type])(ToString(shaderId)) << endl;
		InfoLog.PopStyle();
	}
#endif

#endif
	
	if(shaderId==0) return null;
	auto result = new ShaderObject{shaderId};
	created_shader_objects.AddLast(result);
	return result;
}

//Освободить шейдер
void GraphicsGL::ShaderObjectDelete(ShaderObject* sh)
{
	if(context==null || sh==null) return;
	gl.DeleteShader(sh->id);

#ifndef _NO_LOGGING
	if(InfoLog)
	{
		InfoLog.PushStyle("info");
		InfoLog << "Шейдер "+ToString(sh->id)+" удалён!" << endl;
		InfoLog.PopStyle();
	}
#endif
	created_shader_objects.FindAndRemoveUnordered(sh);
	delete sh;
}



struct AGraphics::ShaderProgram
{
	uint id;
	ShaderInfo info;
};

void GraphicsGL::ShaderDelete(ShaderProgram* sh)
{
	if(context==null || sh==null) return;
	gl.DeleteProgram(sh->id);
	created_shaders.FindAndRemoveUnordered(sh);
	delete sh;
}

void GraphicsGL::ShaderSetUniform(ShaderProgram* sh, uintptr id, uint count, UniformType type, const void* value)
{
	const ValueType vt=type.ToValueType();
	assert(vt.IsValid());
	assert(vt.value<ValueType::Half || vt.value>ValueType::HVec4);
	assert(vt.value<=(uint)ValueType::UVec4);

	typedef void(GLCALL *UFUNC)(int loc, uintptr count, const void* value);
	static const UFUNC uniform_setters[]=
	{
		(UFUNC)gl.Uniform1fv, (UFUNC)gl.Uniform2fv, (UFUNC)gl.Uniform3fv, (UFUNC)gl.Uniform4fv,
		(UFUNC)gl.Uniform1dv, (UFUNC)gl.Uniform2dv, (UFUNC)gl.Uniform3dv, (UFUNC)gl.Uniform4dv,
		null,null,null,null,
		null,
		(UFUNC)gl.Uniform1iv, (UFUNC)gl.Uniform2iv, (UFUNC)gl.Uniform3iv, (UFUNC)gl.Uniform4iv,
		(UFUNC)gl.Uniform1uiv, (UFUNC)gl.Uniform2uiv, (UFUNC)gl.Uniform3uiv, (UFUNC)gl.Uniform4uiv
	};

	if(bound_shader!=sh->id) {gl.UseProgram(sh->id); bound_shader=sh->id;}
	if(uniform_setters[vt.value-1]==null) assert(!"В GraphicsGL::ShaderSetUniform передан неверный тип!");
	uniform_setters[vt.value-1]((int)id, count, value);
}

void GraphicsGL::ShaderSetUniformMatrix(ShaderProgram* sh, uintptr id, uint count, ValueType type, const void* value)
{
	assert(type.IsMatrix());
	typedef void(GLCALL *UFUNC)(int loc, uintptr count, bool transpose, const void* value);
	static const UFUNC uniform_setters[]=
	{
		(UFUNC)gl.UniformMatrix2fv,
	#if(MINEXE<=1)
		(UFUNC)gl.UniformMatrix2x3fv, (UFUNC)gl.UniformMatrix2x4fv, (UFUNC)gl.UniformMatrix3x2fv,
	#else
		null, null, null,
	#endif
		(UFUNC)gl.UniformMatrix3fv,
	#if(MINEXE<=1)
		(UFUNC)gl.UniformMatrix3x4fv, (UFUNC)gl.UniformMatrix4x2fv, (UFUNC)gl.UniformMatrix4x3fv,
	#else
		null, null, null,
	#endif
		(UFUNC)gl.UniformMatrix4fv,

	#if(MINEXE<=1)
		(UFUNC)gl.UniformMatrix2dv, (UFUNC)gl.UniformMatrix2x3dv, (UFUNC)gl.UniformMatrix2x4dv,
		(UFUNC)gl.UniformMatrix3x2dv, (UFUNC)gl.UniformMatrix3dv, (UFUNC)gl.UniformMatrix3x4dv,
		(UFUNC)gl.UniformMatrix4x2dv, (UFUNC)gl.UniformMatrix4x3dv, (UFUNC)gl.UniformMatrix4dv
	#else
		null, null, null, null, null, null, null, null, null
	#endif
	};
	if(bound_shader!=sh->id) {gl.UseProgram(sh->id); bound_shader=sh->id;}
	uniform_setters[type.value-ValueType::FirstOfMatrices]((int)id, count, false, value);
}

void GraphicsGL::ShaderGetUniformValue(ShaderProgram* sh, uintptr id, UniformType type, void* value)
{
	assert((int)id!=-1);
	assert(type.IsValid());
	typedef void(GLCALL *UFUNC)(uint prog, int loc, void* value);
	static const UFUNC uniform_getters[]={(UFUNC)gl.GetUniformfv, (UFUNC)gl.GetUniformdv, (UFUNC)gl.GetUniformiv, (UFUNC)gl.GetUniformuiv};
	
	ushort getterIndex;
	const auto st=type.ToValueType().ToScalarType(); //Чтобы учесть, что сэмплер - это тоже int
	if(st==ValueType::Float) getterIndex=0;
	else if(st==ValueType::Double) getterIndex=1;
	else if(st==ValueType::Int) getterIndex=2;
	else if(st==ValueType::UInt) getterIndex=3;
	else
	{
		assert(!"В GraphicsGL::ShaderGetUniformValue передан неверный тип!");
		return;
	}

	uniform_getters[getterIndex](sh->id, (int)id, value);
}


AGraphics::ShaderProgram* GraphicsGL::ShaderLink(ShaderObject* vertexObj, ShaderObject* fragObj,
	ShaderObject* geomObj, ShaderObject* tessControlObj, ShaderObject* tessEvalObj,
	ArrayRange<const AttribBinding> attribLocBindings, string* linkLog)
{
	assert(vertexObj!=null && fragObj!=null);
	if(vertexObj==null || fragObj==null) return null;

	//Присоединяем шейдеры к программе
	uint progId = gl.CreateProgram();
	gl.AttachShader(progId, vertexObj->id);
	gl.AttachShader(progId, fragObj->id);
	if(geomObj!=null) gl.AttachShader(progId, geomObj->id);
	if(tessControlObj!=null) gl.AttachShader(progId, tessControlObj->id);
	if(tessEvalObj!=null) gl.AttachShader(progId, tessEvalObj->id);

	//Фиксируем вершинные атрибуты
	for(auto& binding: attribLocBindings)
		gl.BindAttribLocation(progId, binding.id, binding.name.CStr());

	gl.LinkProgram(progId);

	//Отсоединяем шейдеры после линковки
	gl.DetachShader(progId, vertexObj->id);
	gl.DetachShader(progId, fragObj->id);
	if(geomObj!=null) gl.DetachShader(progId, geomObj->id);
	if(tessControlObj!=null) gl.DetachShader(progId, tessControlObj->id);
	if(tessEvalObj!=null) gl.DetachShader(progId, tessEvalObj->id);

#ifndef NO_ERROR_CHECKING
	//Получаем лог компиляции
	string log;
	int infoLogLength; gl.GetProgramiv(progId, GL::INFO_LOG_LENGTH, &infoLogLength);
	if(infoLogLength>1)
	{
		auto infobuf=Memory::Buffer::Allocate(infoLogLength+1);
		gl.GetProgramInfoLog(progId, infoLogLength, null, (char*)infobuf->Data);
		log = string(infobuf.ptr, (char*)infobuf->Data, (char*)infobuf->Data+infoLogLength);
		log = log.Trim();
		if(!log.Contains("warn") && !log.Contains("Warn") && !log.Contains("WARN") &&
			!log.Contains("error") && !log.Contains("Error") && !log.Contains("ERROR") || log=="No errors.")
			log=null;
	}
	if(linkLog!=null) *linkLog=log;

	//Если произошла ошибка, удаляем программу
	int success; gl.GetProgramiv(progId, GL::LINK_STATUS, &success);
	if(!success)
	{
		gl.DeleteProgram(progId);
		progId=0;
	}

#ifndef _NO_LOGGING
	if(log!=null) //Если в логе компиляции что-то есть, выводим его
	{
		AppLogger* printLogger=null;
		if(!success) printLogger=&ErrorLog;
		else printLogger=&WarnLog;

		printLogger->PushStyle(success? StringView("warn"): StringView("error"));
		*printLogger << endl << "Лог компоновки шейдеров " << vertexObj->id << ", " << fragObj->id <<
			" и " << (geomObj==null? 0: geomObj->id) << ":" << endl << log << endl;
		printLogger->PopStyle();
	}
#endif

#else

	if(linkLog!=null) *linkLog=null;

#endif

	if(progId==0) return null;

#ifndef _NO_LOGGING
	InfoLog.PushStyle("info");
	InfoLog << "Шейдеры " << vertexObj->id << ", " << fragObj->id << 
		(geomObj!=null? (" и "+ToString(geomObj->id)): null) << " скомпонованы в программу с id=" << progId << endl;
	InfoLog.PopStyle();
#endif


	//Получаем всю информацию о шейдере
	int maxUNL=0; gl.GetProgramiv(progId, GL::ACTIVE_UNIFORM_MAX_LENGTH, &maxUNL);
	int maxUBNL=0; gl.GetProgramiv(progId, GL::ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, &maxUBNL);
	int maxANL=0; gl.GetProgramiv(progId, GL::ACTIVE_ATTRIBUTE_MAX_LENGTH, &maxANL);
	int uniformCount=0; gl.GetProgramiv(progId, GL::ACTIVE_UNIFORMS, &uniformCount);
	int uniformBlockCount=0; gl.GetProgramiv(progId, GL::ACTIVE_UNIFORM_BLOCKS, &uniformBlockCount);
	int attribCount=0; gl.GetProgramiv(progId, GL::ACTIVE_ATTRIBUTES, &attribCount);

	auto result = new ShaderProgram{progId};

	//Выделяем память сразу для всех строк без нулевого символа с запасом
	uint nameBufferSize = max(maxUNL-1, 0)*uniformCount;
	nameBufferSize += max(maxUBNL-1, 0)*uniformBlockCount;
	nameBufferSize += max(maxANL-1, 0)*attribCount+1;
	auto strBuf = Memory::Buffer::Allocate(nameBufferSize);
	char* strEnd = (char*)strBuf->Data;

	result->info.UniformBlocks.SetCount(uniformBlockCount);

	for(int i=0; i<attribCount; i++)
	{
		ShaderInfo::Attribute attr;
		GLenum gl_Type; int size; int strLen;
		gl.GetActiveAttrib(progId, i, maxANL, &strLen, &size, &gl_Type, strEnd);
		attr.Location = (byte)gl.GetAttribLocation(progId, strEnd);
		if(attr.Location==255) continue;
		attr.Type = uniformTypeFromGL[(ushort)gl_Type].ToValueType();
		attr.Name = string(strBuf.ptr, strEnd, (char*)strEnd+strLen);
		strEnd += strLen; //Смещаем конец на только что записанный нулевой символ, чтобы в следующий раз он затёрся
		result->info.Attributes.AddLast(attr);
	}

	for(int i=0; i<uniformBlockCount; i++)
	{
		int binding;
		gl.GetActiveUniformBlockiv(progId, i, GL::UNIFORM_BLOCK_BINDING, &binding);
		int strLen;
		gl.GetActiveUniformBlockName(progId, i, maxUBNL, &strLen, strEnd);
		string ubName = string(strBuf.ptr, strEnd, (char*)strEnd+strLen);
		strEnd+=strLen;
	}

	for(uint i=0; i<(uint)uniformCount; i++)
	{
		ShaderInfo::Uniform u;
		GLenum gl_Type; int strLen;
		gl.GetActiveUniform(progId, i, maxUNL, &strLen, (int*)&u.ArraySize, &gl_Type, strEnd);
		u.Name = string(strBuf.ptr, strEnd, (char*)strEnd+strLen);
		u.Type = uniformTypeFromGL[(ushort)gl_Type];
		int blockIndex=-1;

#ifndef MINIMIZE_GL
		if(gl.Caps.uniform_buffer_object)
			gl.GetActiveUniformsiv(progId, 1, &i, GL::UNIFORM_BLOCK_INDEX, &blockIndex);
#endif
		if(blockIndex==-1)
		{
			u.MatrixStride = 0;
			u.ArrayStride = 0;
			u.LocOrOffset = gl.GetUniformLocation(progId, strEnd);
			//result->info.DefaultValues;
		}
#ifndef MINIMIZE_GL
		else
		{
			int arrayStride=0, matrixStride=0, isRowMajor=0;
			gl.GetActiveUniformsiv(progId, 1, &i, GL::UNIFORM_OFFSET, (int*)&u.LocOrOffset);
			gl.GetActiveUniformsiv(progId, 1, &i, GL::UNIFORM_ARRAY_STRIDE, &arrayStride);
			if(u.Type.IsMatrix())
			{
				gl.GetActiveUniformsiv(progId, 1, &i, GL::UNIFORM_IS_ROW_MAJOR, &isRowMajor);
				gl.GetActiveUniformsiv(progId, 1, &i, GL::UNIFORM_MATRIX_STRIDE, &matrixStride);
			}
			u.ArrayStride=(ushort)arrayStride;
			u.MatrixStride=(byte)(matrixStride|(isRowMajor << 7));
		}
#endif
		strEnd+=strLen; //Смещаем конец на только что записанный нулевой символ, чтобы в следующий раз он затёрся
		if(u.Name.EndsWith("[0]"))
		{
			u.Name = u.Name(0, $-3);
			strEnd-=3;
		}

		if(blockIndex==-1)
		{
			result->info.DefaultBlock.AddLast(u);
		}
		else
		{
			result->info.UniformBlocks[blockIndex].uniforms.AddLast(u);
		}
	}
	assert(strEnd<=(char*)strBuf->End);
	
	created_shaders.AddLast(result);
	return result;
}

const ShaderInfo& GraphicsGL::ShaderGetInfo(ShaderProgram* sh)
{
	return sh->info;
}

intptr GraphicsGL::ShaderUniformGetId(ShaderProgram* sh, StringView uname)
{
	if(sh==null) return -1;
	//assert(gl.IsProgram(sh->id));
	return gl.GetUniformLocation(sh->id, string(uname).CStr());
}



AGraphics::BufferView* GraphicsGL::BufferViewCreate(MemoryBlock* block, uint start, uint size)
{
	uint id=0;
	gl.GenBuffers(1, &id);
	gl.BindBuffer(GL::ARRAY_BUFFER, id);
#ifndef MINIMIZE_GL
	byte usage = byte(block->flags);
	if(gl.Caps.buffer_storage)
	{
		GLenum flags=0;
		if((usage & byte(MemoryFlags::DeviceLocal)) == 0) flags |= GL::CLIENT_STORAGE_BIT;
		if(usage & byte(MemoryFlags::HostWritable)) flags |= GL::MAP_WRITE_BIT|GL::DYNAMIC_STORAGE_BIT;
		if(usage & byte(MemoryFlags::HostReadable)) flags |= GL::MAP_READ_BIT;
		if(usage & byte(MemoryFlags::HostPersistent))
		{
			if((usage & byte(MemoryFlags::HostReadWrite)) == 0)
			{
#ifndef _NO_LOGGING
				if(ErrorLog)
				{
					ErrorLog.PushStyle("error");
					ErrorLog << "Error creating buffer: HostPersistent bit, but not HostReadable or HostWritable bits specified." << IO::endl;
					ErrorLog.PopStyle();
				}
#endif
			}
			flags |= GL::MAP_PERSISTENT_BIT;
		}
		if(usage & byte(MemoryFlags::HostCoherent))
		{
			if(usage & byte(MemoryFlags::HostPersistent) == 0)
			{
#ifndef _NO_LOGGING
				if(ErrorLog)
				{
					ErrorLog.PushStyle("error");
					ErrorLog << "Error creating buffer: HostCoherent bit, but not HostPersistent bit specified." << IO::endl;
					ErrorLog.PopStyle();
				}
#endif
			}
			flags |= GL::MAP_COHERENT_BIT;
		}
		//Флаг HostCached в OpenGL никак не используется
		//Флаг HostStreamed использовался только как хинт для не-immutable storage

		gl.BufferStorage(GL::ARRAY_BUFFER, size, nullptr, flags);
	}
	else
#endif
	{
		GLenum glusage = GL::STATIC_COPY;
		if(usage & byte(MemoryFlags::HostWritable))
		{
			if(usage & byte(MemoryFlags::HostStreamed))
			{
				if(usage & byte(MemoryFlags::HostReadable))
					glusage=GL::STREAM_READ;
				else glusage=GL::STREAM_DRAW;
			}
			else
			{
				if(usage & byte(MemoryFlags::HostReadable))
					glusage=GL::DYNAMIC_READ;
				else glusage=GL::DYNAMIC_DRAW;
			}
		}
		else if(usage & byte(MemoryFlags::HostReadable))
			glusage=GL::STATIC_READ;
		gl.BufferData(GL::ARRAY_BUFFER, size, nullptr, glusage);
	}

#ifndef _NO_LOGGING
	if(InfoLog)
	{
		InfoLog.PushStyle("info");
		InfoLog << string::Format("Создан буфер с id=<^>, size=<^>.")(id)(size) << endl;
		InfoLog.PopStyle();
	}
#endif

	BufferView* result = new BufferView;
	result->id = id;
	result->size = size;
	result->inited = false;
	result->block = block;
	result->startInBlock = start;
	result->lock_access = LockAccess::NoLock;
	result->unsychronized_lock = false;
	result->locked_start = result->locked_end=0;
	created_buffers.AddLast(result);
	return result;
}

void GraphicsGL::BufferRead(BufferView* src, uint startPos, void* dst, uint bytes)
{
	gl.BindBuffer(GL::ARRAY_BUFFER, src->id);
#if(!GLES)
	gl.GetBufferSubData(GL::ARRAY_BUFFER, startPos, bytes, dst);
#else
	void* lockedPtr;
	if(gl.MapBufferRange!=null)
	{
		lockedPtr = gl.MapBufferRange(GL::ARRAY_BUFFER, startPos, bytes, GL::MAP_READ_BIT);
		memcpy(dst, lockedPtr, bytes);
		gl.UnmapBuffer(GL::ARRAY_BUFFER);
	}
	else assert(!"BufferRead is not implemented for OpenGL ES 2.0!");
#endif
}

void GraphicsGL::BufferWrite(BufferView* dst, uint startPos, const void* src, uint bytes)
{
	assert(dst!=null);
	gl.BindBuffer(GL::ARRAY_BUFFER, dst->id);
	gl.BufferSubData(GL::ARRAY_BUFFER, startPos, bytes, src);
	dst->inited=true;
}

void GraphicsGL::BufferMemcpy(BufferView* src, uint srcPos, BufferView* dst, uint dstPos, uint bytes)
{
	assert(src!=null);
	assert(dst!=null);
	assert(src->lock_access==LockAccess::NoLock);
	assert(dst->lock_access==LockAccess::NoLock);

	if(caps.CopyBuffer)
	{
		gl.BindBuffer(GL::COPY_READ_BUFFER, src->id);
		gl.BindBuffer(GL::COPY_WRITE_BUFFER, dst->id);
		gl.CopyBufferSubData(GL::COPY_READ_BUFFER, GL::COPY_WRITE_BUFFER, srcPos, dstPos, bytes);
		if(src->inited) dst->inited=true;
		return;
	}

#ifndef MINIMIZE_GL
	auto lockedData = BufferLock(dst, dstPos, dstPos+bytes, LockAccess::Overwrite, false);
	if(lockedData!=null)
	{
		BufferRead(src, srcPos, lockedData, bytes);
		BufferUnlock(dst);
		return;
	}

	void* dstMap = Memory::Allocate(bytes);
	BufferRead(src, srcPos, dstMap, bytes);
	BufferWrite(dst, dstPos, dstMap, bytes);
	Memory::Free(dstMap);
#endif
}

void GraphicsGL::BufferCopyToTexture(BufferView* hsrc, uintptr srcPos, Texture* hdst, uint mipLevel, usvec3 dstPos, usvec3 dstSize, uint lineAlignment)
{
	current_pixel_unpack_buf=hsrc;
	TextureSetData(hdst, mipLevel, dstPos, dstSize, hdst->info.Format, (void*)srcPos, false, lineAlignment);
	current_pixel_unpack_buf=null;
}

void GraphicsGL::BufferCopyFromTexture(Texture* hsrc, uint mipLevel, usvec3 srcPos, usvec3 srcSize, BufferView* hdst, uintptr dstPos, uint lineAlignment)
{
	current_pixel_pack_buf=hdst;
	TextureGetData(hsrc, mipLevel, srcPos, srcSize, hsrc->info.Format, (void*)dstPos, false, lineAlignment);
	current_pixel_pack_buf=null;
}

void* GraphicsGL::BufferLock(BufferView* buf, uint start, uint end, LockAccess access, bool unsynchronized)
{
	assert(buf!=null);
	gl.BindBuffer(GL::ARRAY_BUFFER, buf->id);
	buf->lock_access=access;
	buf->unsychronized_lock=unsynchronized;
	buf->locked_start=start;
	buf->locked_end=end;
	if(gl.MapBufferRange!=null)
	{
		static const ushort gl_flags[] = {GL::MAP_READ_BIT,
			GL::MAP_WRITE_BIT, GL::MAP_READ_BIT|GL::MAP_WRITE_BIT, GL::MAP_WRITE_BIT};

		auto gl_access = gl_flags[(byte)access];

		if(access==LockAccess::Overwrite && buf->inited)
			gl_access |= (start==0 && end==buf->size)? GL::MAP_INVALIDATE_BUFFER_BIT: GL::MAP_INVALIDATE_RANGE_BIT;

		if(unsynchronized)
			gl_access |= GL::MAP_UNSYNCHRONIZED_BIT;

		if(access!=LockAccess::Read) buf->inited=true;

		return gl.MapBufferRange(GL::ARRAY_BUFFER, start, end-start, gl_access);
	}
#ifndef MINIMIZE_GL
	else
#if(!GLES) //На PC существует с момента появления VBO, а на мобильных устройствах есть только расширение с доступом только для записи, которое здесь не используется
	{
		static const ushort gl_flags[] = {GL::READ_ONLY, GL::WRITE_ONLY, GL::READ_WRITE, GL::WRITE_ONLY};
		auto address = (byte*)gl.MapBuffer(GL::ARRAY_BUFFER, gl_flags[(ushort)access]);
		if(access!=LockAccess::Read) buf->inited=true;
		return address+start;
	}
#else
	{assert(false); return null;} //Не поддерживается, эмуляцию делать не буду
#endif
#else
	return null;
#endif
}

bool GraphicsGL::BufferUnlock(BufferView* buf)
{
	if(buf==null) return false;
	if(buf->lock_access==LockAccess::NoLock) return true;
	gl.BindBuffer(GL::ARRAY_BUFFER, buf->id);
	buf->lock_access=LockAccess::NoLock;
	buf->locked_start=buf->locked_end=0;
	buf->unsychronized_lock=false;
	return gl.UnmapBuffer(GL::ARRAY_BUFFER);
}

void GraphicsGL::BufferViewDelete(BufferView* buf)
{
	if(context==null || buf==null) return;
	gl.DeleteBuffers(1, &buf->id);
#ifndef _NO_LOGGING
	if(InfoLog)
	{
		InfoLog.PushStyle("info");
		InfoLog << string::Format("Буфер <^> удалён!")(buf->id) << endl;
		InfoLog.PopStyle();
	}
#endif
	created_buffers.FindAndRemoveUnordered(buf);
}

AGraphics::Sync* GraphicsGL::SyncFenceCreate()
{
	gl.MemoryBarrier(GL::ALL_BARRIER_BITS);
	return (Sync*)gl.FenceSync(GL::SYNC_GPU_COMMANDS_COMPLETE, 0);
}

void GraphicsGL::SyncDelete(Sync* sync)
{
	gl.DeleteSync((OpenGL::GLsync)sync);
}

void GraphicsGL::SyncWait(Sync* sync)
{
	gl.WaitSync((OpenGL::GLsync)sync, 0, GL::TIMEOUT_IGNORED);
}

bool GraphicsGL::SyncClientWait(Sync* sync, ulong64 timeout)
{
	GLenum result = gl.ClientWaitSync((OpenGL::GLsync)sync, 0, timeout);
	if(result==GL::ALREADY_SIGNALED || result==GL::CONDITION_SATISFIED) return true;
	if(result==GL::GL_WAIT_FAILED || result==GL::TIMEOUT_EXPIRED) return false;
	return false;
}



struct AGraphics::VertexAttribState
{
	uint vao;
	flag32 vaoAttributes; //Постоянные атрибуты VAO
	flag32 boundAttributes; //Вершинному шейдеру могут быть нужны не все атрибуты, это те, которые включены в данный момент
	PodArray<uint> strides;
	PodArray<uint> offsets;
	PodArray<AGraphics::AttributeStream> streams;
	AGraphics::BufferView* indexBuffer;
	uint FirstVertex;
	bool indices32bit;
};

static void VertexAttribStateSet(AGraphics::VertexAttribState* vas, ArrayRange<const AGraphics::AttributeStream> streams,
	AGraphics::BufferView* indexBuffer, bool indices32bit, const OpenGL& gl)
{
	uint si=0;
	indices32bit;
	for(auto& s: streams)
	{
		auto& stride = vas->strides[si];

		gl.BindBuffer(GL::ARRAY_BUFFER, s.Buffer->id);
		byte* offset=0;
		for(ushort i=0; i<16 && s.Attributes[i].type!=ValueType::Void; i++)
		{
			const auto& attr = s.Attributes[i];

			const auto gl_type = attribTypeToGLType(attr.type);
			if(attr.type.IsInteger())
				gl.VertexAttribIPointer(attr.loc, attr.type.Dimensions(),
					gl_type, stride, offset + vas->FirstVertex*stride);
			else
				gl.VertexAttribPointer(attr.loc, attr.type.Dimensions(),
					gl_type, attr.type.IsNormalized(), stride, offset + vas->FirstVertex*stride);

			offset += attr.type.Size();
		}
		si++;
	}
	if(indexBuffer!=null)
		gl.BindBuffer(GL::ELEMENT_ARRAY_BUFFER, indexBuffer->id);
}

AGraphics::VertexAttribState* GraphicsGL::VertexAttribStateCreate(ArrayRange<const AttributeStream> streams,
	BufferView* indexBuffer, uint firstVertex, bool indices32bit)
{
	auto vas = new VertexAttribState;
	vas->vao = 0;
	vas->boundAttributes = 0;
	vas->vaoAttributes = 0;
	vas->FirstVertex = firstVertex;
	for(auto& s: streams)
	{
		//Вычисляем смещение каждой следующей вершины в буфере этого потока
		uint stride = 0;
		for(ushort i=0; s.Attributes[i].type!=ValueType::Void; i++)
		{
			auto attribyteType = s.Attributes[i].type;
			assert(attribyteType.IsVector() || attribyteType.IsScalar());
			stride += attribyteType.Size();

			const auto& attr = s.Attributes[i];
			assert((vas->vaoAttributes & (1 << attr.loc))==0);
			vas->vaoAttributes |= (1 << attr.loc);
		}
		vas->strides.AddLast(stride);
	}

//#ifndef MINIMIZE_GL
	if(gl.Caps.vertex_array_object)
	{
		gl.GenVertexArrays(1, &vas->vao);
		gl.BindVertexArray(vas->vao);
		VertexAttribStateSet(vas, streams, indexBuffer, indices32bit, gl);
	}
//#endif
	vas->streams = streams;
	vas->indexBuffer = indexBuffer;
	vas->indices32bit = indices32bit;

	created_vertex_attrib_states.AddLast(vas);
	return vas;
}

void GraphicsGL::VertexAttribStateBind(AGraphics::VertexAttribState* vaState, flag32 enabledAttribs)
{
//#ifndef MINIMIZE_GL
	if(gl.Caps.vertex_array_object && current_state.vertex_attrib_state!=vaState)
	{
		gl.BindVertexArray(vaState==null? empty_vao: vaState->vao);
	}
//#endif
	current_state.vertex_attrib_state = vaState;
	if(vaState==null) return;

//#ifndef MINIMIZE_GL
	if(!gl.Caps.vertex_array_object)
//#endif
	{
		VertexAttribStateSet(vaState, vaState->streams, vaState->indexBuffer, vaState->indices32bit, gl);
	}
//#ifndef MINIMIZE_GL
	if(gl.Caps.vertex_array_object)
		if(enabledAttribs==vaState->boundAttributes) return;
//#endif
	for(ushort i=0; i<16; i++)
	{
		const bool isEnabled = (vaState->boundAttributes & (1 << i))!=0;
		const bool enable = (enabledAttribs & (1 << i))!=0;
		if(!gl.Caps.vertex_array_object || isEnabled!=enable)
			gl.DisEnableVertexAttribArray[enable](i);
	}
	vaState->boundAttributes = enabledAttribs;
}

void GraphicsGL::VertexAttribStateDelete(VertexAttribState* vas)
{
	if(context==null || vas==null) return;
//#ifndef MINIMIZE_GL
	if(gl.Caps.vertex_array_object)
		gl.DeleteVertexArrays(1, &vas->vao);
//#endif
	created_vertex_attrib_states.FindAndRemoveUnordered(vas);
	delete vas;
}



struct AGraphics::Framebuffer
{
	uint id;
	PodArray<FramebufferAttachment> colorAttachments;
	FramebufferAttachment depthAttachment, stencilAttachment;
};



GraphicsGL::Framebuffer* GraphicsGL::FramebufferCreate(ArrayRange<const FramebufferAttachment> colorAttachments,
	const FramebufferAttachment& depthAttachment, const FramebufferAttachment& stencilAttachment)
{
	gl.GenFramebuffers(1, &bound_draw_fbo);
	gl.BindFramebuffer(GL::FRAMEBUFFER, bound_read_fbo=bound_draw_fbo);
	for(byte i=0; i<colorAttachments.Count(); i++)
	{
		if(colorAttachments[i].tex==null) continue;
		setFramebufferTexture(colorAttachments[i], i, gl, GL::FRAMEBUFFER);
	}
	if(depthAttachment.tex!=null) setFramebufferTexture(depthAttachment, -1, gl, GL::FRAMEBUFFER);
	if(stencilAttachment.tex!=null) setFramebufferTexture(stencilAttachment, -2, gl, GL::FRAMEBUFFER);

#ifndef _NO_LOGGING
	auto status = gl.CheckFramebufferStatus(GL::FRAMEBUFFER);
	if(status!=GL::FRAMEBUFFER_COMPLETE)
	{
		ErrorLog.PushStyle("error");

		ErrorLog << "OpenGL: FBO is incomplete: 0x"+ToString(status, 4, '0', 16) << endl;

		for(byte i=0; i<colorAttachments.Count(); i++)
		{
			ErrorLog << "color target "+ToString(i)+": { "+texture_ToString(colorAttachments[i].tex, gl.Caps.texture_swizzle) << " }" << endl <<
				string::Format("    slice=<^>, miplevel=<^>")(colorAttachments[i].slice)(colorAttachments[i].miplevel) << endl;
		}

		ErrorLog << "depth target: { "+texture_ToString(depthAttachment.tex, gl.Caps.texture_swizzle) << " }" << endl <<
			string::Format("    slice=<^>, miplevel=<^>")(depthAttachment.slice)(depthAttachment.miplevel) << endl;

		ErrorLog.PopStyle();
	}
#endif

	auto result = new Framebuffer{bound_draw_fbo, PodArray<FramebufferAttachment>(colorAttachments), depthAttachment, stencilAttachment};
	created_framebuffers.AddLast(result);
	return result;
}

void GraphicsGL::FramebufferBind(Framebuffer* fbo, usvec2 viewportPos, usvec2 viewportSize)
{
	current_read_fbo = current_draw_fbo = 0;
	if(fbo!=null) current_read_fbo = current_draw_fbo = fbo->id;
	if(bound_draw_fbo!=current_draw_fbo || bound_read_fbo!=current_read_fbo)
	{
		gl.BindFramebuffer(GL::FRAMEBUFFER, bound_read_fbo=bound_draw_fbo=current_draw_fbo);
	}

	current_state.viewport_pos = viewportPos;
	current_state.viewport_size = viewportSize;
	gl.Viewport(viewportPos.x, viewportPos.y, viewportSize.x, viewportSize.y);

	if(fbo!=null)
	{
		GLenum bufs[8];
		for(uint i=0; i<fbo->colorAttachments.Count(); i++)
			bufs[i] = (fbo->colorAttachments[i].tex!=null)? GL::COLOR_ATTACHMENT0+i: 0;
		gl.DrawBuffers((int)fbo->colorAttachments.Count(), bufs);
	}
	else
	{
		gl.DrawBuffer(GL::BACK);
	}

	if(fbo!=null) for(auto& at: fbo->colorAttachments)
		if(at.tex!=null && at.tex->mipstate==MipmapState::AutoGenerate)
			at.tex->mipstate=MipmapState::AutoGenerateDirty;

	current_state.framebuffer=fbo;
}

void GraphicsGL::FramebufferDelete(Framebuffer* fbo)
{
	if(context==null || fbo==null || fbo->id==0) return;
	gl.DeleteFramebuffers(1, &fbo->id);
	created_framebuffers.FindAndRemoveUnordered(fbo);
	delete fbo;
}


void GraphicsGL::SetupStates(const RenderState* states)
{
	auto& cs = current_state.render_states;
	auto& st = *states;
	if(core::memcmp(&st, &cs, sizeof(RenderState))==0) return;

	if(gl.PolygonMode) gl.PolygonMode(GL::FRONT_AND_BACK, polyModeConvertTable[(ushort)st.PolygonMode]);
	else assert(st.PolygonMode==PolyMode::Fill);
	gl.DisEnable[states->BlendEnabled](GL::BLEND);
	if(st.BlendEnabled) gl.BlendFunc(blendFactorConvertTable[(ushort)states->SrcBlend], blendFactorConvertTable[(ushort)states->DstBlend]);
	gl.DisEnable[states->DepthTestEnabled](GL::DEPTH_TEST); //Note that even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. See gl.DepthFunc and gl.DepthRangef.
	gl.DepthMask(states->DepthWriteEnabled);
	gl.DisEnable[states->CullBackFaces](GL::CULL_FACE);

	if(cs.RedWriteEnabled!=st.RedWriteEnabled ||
		cs.GreenWriteEnabled!=st.GreenWriteEnabled ||
		cs.BlueWriteEnabled!=st.BlueWriteEnabled ||
		cs.AlphaWriteEnabled!=st.AlphaWriteEnabled)
		    gl.ColorMask(st.RedWriteEnabled, st.GreenWriteEnabled, st.BlueWriteEnabled, st.AlphaWriteEnabled);

	//Если у нас мультисемплинг, то мы хотим сглаживать не только полигональные объекты, но и объекты с альфа-тестом
	if(gl.SampleCoverage!=null)
	{
		gl.DisEnable[st.AlphaToCoverageEnabled](GL::SAMPLE_ALPHA_TO_COVERAGE);
		gl.SampleCoverage(0.25, false);
	}

	cs=st;
}


void GraphicsGL::TextureBind(Texture* tex, Sampler* samp, uint slot)
{
	uint texid=0;
	if(tex!=null)
	{
		assert(created_textures.Contains(tex));
		texid=tex->id;
	}
	if(current_state.textures[slot]==null && texid==0) return;

	GLenum texType;
	if(texid==0) texType=GL::TEXTURE_2D;
	else texType = ImageTypeToGLTarget(tex->info.Type);

	if(active_texture_slot!=slot)
	{
		gl.ActiveTexture(GL::TEXTURE0+slot);
		active_texture_slot=slot;
	}
	current_state.textures[slot]=tex;
	if(bound_textures[slot]!=tex)
	{
		bound_textures[slot]=tex;
		gl.BindTexture(texType, texid);
	}
	if(tex==null) return;

	if(samp==null) samp=default_sampler;

	if(tex->mipstate==MipmapState::AutoGenerateDirty && samp->desc.MipFilter!=TexFilter::None)
	{
		gl.GenerateMipmap(texType);
		tex->mipstate=MipmapState::AutoGenerate;
	}

#ifndef MINIMIZE_GL
	if(gl.Caps.sampler_objects)
	{
		if(current_state.samplers[slot]!=samp)
		{
			gl.BindSampler(slot, samp->id);
			current_state.samplers[slot]=samp;
		}
		return;
	}
#endif

	//Установка параметров сэмплера
	TexFilter mipFilter=samp->desc.MipFilter, minFilter=samp->desc.MinFilter;
	if(tex->info.MipmapCount==1)
	{
		mipFilter=TexFilter::None;
		if(minFilter>=TexFilter::AnisotropicX2) minFilter=TexFilter::Linear;
	}
	gl.TexParameteri(texType, GL::TEXTURE_MIN_FILTER, convertMinFilter(minFilter, mipFilter));
	gl.TexParameteri(texType, GL::TEXTURE_MAG_FILTER, texFilterConvertTable[(ushort)samp->desc.MagFilter]);

	ushort anisotropy=1;
	if(samp->desc.MinFilter>=TexFilter::AnisotropicX2)
		anisotropy=min<ushort>(1 << ( 1 + ((short)samp->desc.MinFilter-(short)TexFilter::AnisotropicX2) ), caps.MaxAnisotropy);
	if(caps.MaxAnisotropy>1)
		gl.TexParameteri(texType, GL::TEXTURE_MAX_ANISOTROPY, anisotropy);

	if(texType!=GL::TEXTURE_CUBE_MAP) //Нет смысла повторять кубическую текстуру, поэтому игнорируем параметры текстуры
	{
		gl.TexParameteri(texType, GL::TEXTURE_WRAP_S, texWrapConvertTable[(ushort)samp->desc.WrapS]);
		if(texType!=GL::TEXTURE_1D) gl.TexParameteri(texType, GL::TEXTURE_WRAP_T, texWrapConvertTable[(ushort)samp->desc.WrapT]);
		if(texType==GL::TEXTURE_3D) gl.TexParameteri(texType, GL::TEXTURE_WRAP_R, texWrapConvertTable[(ushort)samp->desc.WrapR]);
	}

	gl.TexParameterf(texType, GL::TEXTURE_MIN_LOD, samp->desc.MinMip);
	gl.TexParameterf(texType, GL::TEXTURE_MAX_LOD, samp->desc.MaxMip);
	gl.TexParameterf(texType, GL::TEXTURE_LOD_BIAS, samp->desc.MipBias);

	gl.TexParameteri(texType, GL::TEXTURE_COMPARE_MODE, texCompareModeConvertTable[(ushort)samp->desc.DepthCompareMode]);
	gl.TexParameteri(texType, GL::TEXTURE_COMPARE_FUNC, compareFuncConvertTable[(ushort)samp->desc.DepthCompareFunc]);
}

void GraphicsGL::SetupTextures(ArrayRange<Texture* const> textures, ArrayRange<Sampler* const> samplers)
{
	ushort i=0;
#ifndef MINIMIZE_GL
	if(gl.Caps.multi_bind)
	{
		if(textures==null)
		{
			gl.BindTextures(0, 32, null);
			for(auto& tex: current_state.textures) tex=null;
			for(auto& tex: bound_textures) tex=null;
			for(auto& samp: current_state.samplers) samp=null;
			return;
		}
		if(gl.Caps.sampler_objects)
		{
			uint texIds[32]={0};
			uint sampIds[32]={0};
			for(; i<textures.Count(); i++)
			{
				if(textures[i]==null)
				{
					current_state.textures[i]=null;
					bound_textures[i]=null;
					continue;
				}
				assert(created_textures.Contains(textures[i]));
				if(textures[i]->mipstate==MipmapState::AutoGenerateDirty) break;

				texIds[i]=textures[i]->id;
				current_state.textures[i]=textures[i];
				bound_textures[i]=textures[i];
				if(samplers[i]==null)
				{
					sampIds[i]=default_sampler->id;
					current_state.samplers[i]=default_sampler;
				}
				else
				{
					sampIds[i]=samplers[i]->id;
					current_state.samplers[i]=samplers[i];
				}
			}
			if(i!=0)
			{
				gl.BindTextures(0, i, texIds);
				gl.BindSamplers(0, i, sampIds);
			}
		}
	}
#endif
	for(; i<32; i++)
	{
		Sampler* samp=null;
		Texture* tex=null;
		if(i<textures.Count())
		{
			tex=textures[i];
			if(i<samplers.Count())
				samp=samplers[i];
		}
		TextureBind(tex, samp, i);
	}
}



void GraphicsGL::Draw(const DrawCall& dc, ShaderProgram* sh, ArrayRange<const UniformBinding> ubindings)
{
	assert(sh!=null);
	if(bound_draw_fbo!=current_draw_fbo)
		gl.BindFramebuffer(GL::DRAW_FRAMEBUFFER, bound_draw_fbo=current_draw_fbo);
	VertexAttribStateBind(dc.VertexState, dc.EnabledAttribs);

	const GLenum primtype = primitiveTypeConvertTable[(ushort)dc.Type];
	if(dc.Instances==0) return;

	auto curShId = (sh==null? 0: sh->id);
	if(bound_shader!=curShId)
		gl.UseProgram(bound_shader=curShId);

	for(auto& binding: ubindings)
	{
		gl.BindBufferBase(GL::UNIFORM_BUFFER, binding.index, binding.buffer->id/*, binding.offset, binding.size*/);
		gl.UniformBlockBinding(curShId, binding.index, binding.index);
	}

	static const ushort frontFaceTable[]={GL::CCW, GL::CW};
	gl.FrontFace(frontFaceTable[dc.Clockwise]);

	int relativeFirstVertex = (int)dc.FirstVertex - (dc.VertexState!=null? (int)dc.VertexState->FirstVertex: 0);
	assert(relativeFirstVertex>=0);
	if(dc.IndexCount!=0)
	{
		assert(dc.VertexState!=null && dc.VertexState->indexBuffer!=null);
		auto indexType = ValueType::UShort;
		assert(indexType==ValueType::UShort || indexType==ValueType::UInt);
		const GLenum gl_Type = attribTypeToGLType(indexType);
		void* offset = (void*)(dc.FirstIndex*(indexType==ValueType::UShort? sizeof(ushort): sizeof(uint)));

		gl.BindBuffer(GL::ELEMENT_ARRAY_BUFFER, dc.VertexState->indexBuffer->id);

#ifndef MINIMIZE_GL
		if(dc.Instances==1)
		{
			if(caps.DrawIndexedFirstVertex)
				gl.DrawRangeElementsBaseVertex(primtype, 0, dc.VertexCount, dc.IndexCount, gl_Type, offset, relativeFirstVertex);
			else if(dc.FirstVertex==dc.VertexState->FirstVertex)
				gl.DrawElements(primtype, dc.IndexCount, gl_Type, offset);
			else assert(!"DrawIndexedFirstVertex не поддерживается!");
			return;
		}
#endif

		if(caps.HardwareInstancing)
		{
			gl.DrawElementsInstancedBaseVertex(primtype, dc.IndexCount, gl_Type, offset, dc.Instances, relativeFirstVertex);
			return;
		}

#ifndef MINIMIZE_GL
		//Эмуляция инстансинга, если он не поддерживается
		const int iidloc = gl.GetUniformLocation(sh->id, "InstanceID");
		for(uint iid=0; iid<dc.Instances; iid++)
		{
			if(iidloc!=-1) gl.Uniform1iv(iidloc, 1, (int*)&iid);
			if(caps.DrawIndexedFirstVertex) gl.DrawRangeElementsBaseVertex(primtype, 0, dc.VertexCount, dc.IndexCount, gl_Type, offset, relativeFirstVertex);
			else if(dc.FirstVertex==dc.VertexState->FirstVertex) gl.DrawElements(primtype, dc.IndexCount, gl_Type, offset);
			else assert(!"DrawIndexedFirstVertex не поддерживается!");
		}
		return;
#endif
	}

	if(caps.HardwareInstancing)
	{
		gl.DrawArraysInstanced(primtype, relativeFirstVertex, dc.VertexCount, dc.Instances);
		return;
	}

#ifndef MINIMIZE_GL
	if(dc.Instances==1)
	{
		gl.DrawArrays(primtype, relativeFirstVertex, dc.VertexCount);
		return;
	}


	const int iidloc=gl.GetUniformLocation(sh->id, "InstanceID");
	for(uint iid=0; iid<dc.Instances; iid++)
	{
		if(iidloc!=-1) gl.Uniform1iv(iidloc, 1, (int*)&iid);
		gl.DrawArrays(primtype, relativeFirstVertex, dc.VertexCount);
	}
#endif
}


AGraphics::BufferView* GraphicsGL::get_temp_ingpu_buffer(uintptr size)
{
	if(temp_ingpu_buffer_size>=size)
		return temp_ingpu_buffer;
	auto oldBlock = temp_ingpu_buffer->block;
	BufferViewDelete(temp_ingpu_buffer);
	MemoryFree(oldBlock);
	temp_ingpu_buffer_size = size;
	auto block = MemoryAllocate(uint(size), MemoryFlags::DeviceLocal);
	return temp_ingpu_buffer = BufferViewCreate(block, 0, uint(size));
}
